## Основы git

1. [Определения](#definitions)
1. [Подготовка](#setting-up)
    1. [Настройка git](#config)
    1. [Инициализация git-репозитория](#init)
    1. [Исключения из-под контроля версий](#gitignore)
1. [Базовые операции](#basics)
    1. [Отслеживание изменений](#tracking)
    1. [Индексация изменённых файлов](#add)
    1. [Фиксация изменений](#commit)
    1. [Просмотр истории коммитов](#log)
    1. [Об указателе `HEAD`](#head)
1. [Метки](#tags)
1. [Ветки](#branches)
    1. [Определения](#branches-definitions)
    1. [Создание ветки](#create-branch)
    1. [Переключение между ветками](#checkout-branch)
    1. [Слияние веток](#merge)
    1. [Перебазирование веток](#rebase)
    1. [Интерактивное перебазирование](#interactive-rebase)
    1. [Отбор лучшего](#cherry-pick)
    1. [Редактирование веток](#branch-force)
    1. [Удаление ветки](#delete-branch)
1. [Навигация по истории коммитов](#navigation)
    1. [Переключение на коммит](#checkout)
    1. [Относительные ссылки](#relative-links)
1. [Редактирование истории](#editing)
    1. [Сброс коммита](#reset)
    1. [Отмена коммита](#revert)
    1. [Редактирование коммита](#amend)
1. [Сокрытие изменений](#stash)
1. [Конфликты](#conflicts)
1. [Удалённые репозитории](#remotes)
    1. [Клонирование репозитория](#clone)
    1. [Связь локального репозитория с удалённым](#remote-add)
    1. [Отправка изменений в удалённый репозиторий](#push)
    1. [Выкладка проекта в удалённый репозиторий](#export)
    1. [Получение изменений из удалённого репозитория](#fetch)
    1. [Синхронизация локального репозитория с удалённым](#pull)

### Определения <a name="definitions"></a>

**Система управления версиями** (Система контроля версий, Version Control System, VCS) - программное обеспечение для 
облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить множество различных 
**состояний** (версий) одного и того же файла; отслеживать изменения в файлах; авторство и последовательность 
изменений; возвращаться к более ранним версиям; объединять множественные изменения одного и того же файла, сделанные 
различными авторами.   
Системы управления версиями повсеместно используются в разработке программного обеспечения для хранения исходных кодов 
программ и отслеживания их изменений.

**Состояние** проекта - это набор всех файлов, находящихся под управлением VCS, и их текущее содержимое (состояние). 
Каждый раз, когда фиксируется (сохраняется) состояние проекта, VCS делает слепок всех файлов, находящихся под её 
управлением. VCS хранит именно состояния проекта; к конкретному состоянию оптом можно вернуться, просмотреть разницу 
между двумя состояниями, сделать ответвление от состояния и так далее.   

**Репозиторий** - хранилище для документов под контролем системы управления версиями, истории их изменения и прочей 
служебной информации. Репозиторий может быть: 
- **локальным** - расположенным на компьютере пользователя (разработчика) и, соответственно, доступный только ему;   
    обычно используется для хранения текущих правок, временных рабочих версий файлов;  
- **удалённым** - расположенным на сервере в информационной сети;   
    к удалённому репозиторию обычно есть доступ у множества пользователей (разработчиков);  
    он используется для публикации изменений, сделанных локально, - в общий доступ для всех пользователей проекта; 
    хранения общей рабочей версии кода; объединения правок, сделанных каждым из пользователей в одну рабочую версию; 
    обновления локальных репозиториев до актуальных версий файлов проекта.

**Git** - распределённая управления версий, которая даёт возможность разработчикам отслеживать изменения в файлах 
исходного кода и работать совместно (параллельно) с другими разработчиками над одними и теми же файлами.  
Git является одной из самых популярных VСS в коммерческой разработке и используется практически повсеместно.  
Git является *распределённой* VCS, т.к. позволяет создавать и локальные и удалённые репозитории, связанные между 
собой.  

**GitHub** - это бесплатный сервис, предоставляющий серверные мощности для хранения в сети пользовательских удалённых 
репозиториев на базе git.  
Зачастую *GitHub* используется для резервного хранения файлов исходного кода пользователей; обмена такими файлами между 
пользователями; проектами с открытым кодом (open source), в которых может принять участие любой сторонний пользователь.  

### Подготовка <a name="setting-up"></a>

#### Настройка git <a name="config"></a>

Первоначальную настройку git достаточно выполнить один раз. Для начала необходимо указать имя пользователя git и его 
электронную почту. Эти данные будут использоваться как подпись автора сделанных изменений при сохранении состояния 
проекта в git. Данные можно указать любые.

Команды:

    git config --global user.name
    git config --global user.email

*считывают* и отображают текущее значение параметров пользователя `user.name` и `user.email`

Команды
       
    git config --global user.name "Your Name"
    git config --global user.email "your_email.@whatever.com"
    
*устанавливают* значения параметров пользователя `user.name` и `user.email` в `Your Name` и `your_email.@whatever.com` 
соответственно.

Ответной реакции на установку новых значений нет. Чтобы проверить установленные значения можно запросить их ещё раз.

Ключ `--global` указывает, что настройка устанавливается для текущего пользователя операционной системы. Ещё варианты: 
- не указывать ключ после `config`: параметры будут считаны / установлены для конкретного проекта;
- указать ключ `--system` вместо `--global`: параметры будут считаны / установлены для всех пользователей операционной 
   системы. 

При необходимости изменить настройки можно позже, теми же командами. 

#### Инициализация git-репозитория <a name="init"></a>

Для подключения имеющегося проекта к системе управления версиями, нужно провести *инициализацию* git-репозитория. 
**Инициализация** - это создание репозитория и его первичная настройка.

Перед этим необходимо определить место хранения файлов git, относящихся к интересующему проекту. Обычно для этого 
используют корневую директорию проекта.  
Необходимо перейти в директорию проекта, команда(ы)

    cd %путь_до_директории_проекта%
    
Находясь в директории проекта, для инициализации git-репозитория необходимо выполнить команду

    git init

В результате в целевой директории появляется скрытая директория .git - это и есть место хранения локального 
git-репозитория. Теперь все файлы (во всех директориях, включая вложенные) проекта - находятся под контролем git. Git 
теперь может отслеживать изменения в файлах проекта и сохранять текущее состояние проекта по запросу.

В среде *IntelliJ IDEA* создать новый git-репозиторий можно:
- вызвав всплывающее меню работы с VSC (<code>Alt + \`</code>), и выбрав `1. Create Git Repository...`
- из верхнего меню: `VCS` => `Import Into Version Control` => `Create Git Repository...`

#### Исключения из-под контроля версий <a name="gitignore"></a>

Далеко не все файлы проекта бывает необходимо хранить под контролем версий. Обычно, под версионным контролем хранят 
файлы исходного кода, и ресурсные файлы проекта (медиа, изображения, и.т.д.). Нет необходимости сохранять (и делиться 
ими с коллегами) файлы настроек проекта, скомпилированные класс-файлы.

Для того чтобы исключить файлы и / или директории из-под контроля версий git, их необходимо указать в специальном файле 
с `.gitignore`.

В корневой папке проекта (точнее, в папке, где был проинициализирован git-репозиторий) необходимо создать файл с именем 
`.gitignore` и в этом файле перечислить пути до файлов / директорий, которые git должен игнорировать. Например:

    /.idea/
    /out/
    /JJD.iml

Отдельная строчка для каждой новой записи. Если указана директория - то игнорироваться будет всё содержимое директории 
включая вложенные директории.   
Пути обычно указываются относительные: относительно директории проекта. Символ `/` в начале строки указывает на 
содержание в текущей директории (директории проекта). Он не обязательный, можно опустить.
Можно использовать маски `*` для замены любых символов (в любом количестве), например запись: `/res/*.jpg` добавит в 
исключения все файлы с расширением `.jpg` в директории `res/` в корне проекта. 

Обычно в `.gitignore` добавляются:
- все файлы `.idea/` - это служебные файлы, которые генерирует сама *IntelliJ IDEA* для работы с проектом.
- все файлы `out/` - скомпилированные класс-файлы. В зависимости от настроек проекта путь для компиляции класс-файлов 
    может отличаться.
- `%имя_проекта%.iml` и прочие файлы настройки проекта (если есть).

Сам файл `.gitignore` должен оставаться под версионным контролем (чтобы другие пользователи могли использовать его же).
Т.е. добавлять `.gitignore` в `.gitignore` не нужно.

В *IntelliJ IDEA* добавить файлы в `.gitignore` можно так же, прописав их в этом файле вручную, а можно из контекстного 
меню: `RMB` на файле или директории в дереве проекта => `Git` => `Add to .gitignore`.

Все файлы, указанные в `.gitignore` будут проигнорированы git. Никакие изменения в них отслеживаться не будут, их 
состояние сохраняться в git не будет.

### Базовые операции <a name="basics"></a>

#### Отслеживание изменений <a name="tracking"></a>

Git автоматически отслеживает все изменения, произошедшие в файлах, находящихся под версионным контролем.  
Новые созданные файлы в отслеживаемых директориях также попадают под версионный контроль. В том числе, все 
не-игнорируемые файлы, как только был создан репозиторий - считаются новыми добавленными файлами.

Фактически, git отслеживает именно *файлы* (и пути до них), директории отслеживаются косвенно: если директория под 
версионным контролем, но пуста, то git про неё ничего "не знает".

Команда 

    git status
    
позволяет получить сводку по всем изменениям в отслеживаемых файлах по сравнению с последним сохранённым состоянием.
В ней указываются новые файлы, добавленные под версионный контроль; удалённые, перемещённые, переименованные файлы; 
файлы, в которых были сделаны изменения.

В *IntelliJ IDEA* статус файлов проекта динамически отображается в дереве проекта (цвета - настраиваемые):
- голубой: изменённые файлы
- красный: новые [не-проиндексированные](#add) файлы;
- зелёный: новые [проиндексированные](#add) файлы.
- тёмно-зелёный - игнорируемые файлы.

А общая сводка текущих локальных изменений доступна в нижнем меню: `Version Control` (`Alt + 9`) => `Local Changes`. 

#### Индексация изменённых файлов <a name="add"></a>

**Сохранение** состояния проекта в git состоит из двух этапов:
- индексация изменённых файлов
- фиксация изменений

**Индексация изменений** - это операция при которой git вычисляет (и подготавливает к сохранению) разницу между текущим 
состоянием файла и известным ему сохранённым состоянием файла (если оно было).

Индексация изменений *обязательна*, для того чтобы git мог сохранить обновлённое состояние. Не-проиндексированные 
изменения сохранены *не будут*. Соответственно, пользователь сам должен определить какие из изменений (какие файлы) 
необходимо сохранить, а какие - нет.

Индексация производится командой 

    git add %имя_файла_или_директории%
    
В качестве *%имени_файла_или_директории%* указывается полный или относительный (относительно текущей директории) путь до 
файла или директории, изменения в которой необходимо проиндексировать.  
Если файл / директория находятся в текущей директории, достаточно указать только имя.  
Добавление директории проиндексирует все не-игнорируемые файлы в этой директории.  
Можно использовать маски `*` для замены любых символов (в любом количестве), например: `git add res/*.jpg` 
проиндексирует изменения во всех файлах с расширением `.jpg` в директории `res/` в корне проекта.  

Файлы / директории командой `git add` добавляются по одному. Команду `git add` необходимо применить ко всем файлам, 
которые нужно сохранить. Возможности указать несколько аргументов - нет.

Команда 

    git add *

или
    
    git add .

проиндексирует вообще все сделанные изменения в не-игнорируемых файлах в текущей директории.

Повторив команду `git status` можно увидеть сводку, какие изменённые файлы проиндексированы (и готовы к сохранению), а 
какие - нет и сохранены не будут.

Новые изменения в файле, сделанные после `git add ` - не проиндексированы, следовательно, сохранены не будут. Чтобы 
избежать потери последних изменений, нужно ещё раз проиндексировать этот файл с помощью `git add`.  
Обычно, индексация и сохранение изменений производятся последовательно сразу, чтобы избежать потерь.

Ошибочно проиндексированный файл можно убрать из набора, подготовленного для сохранения, командой 

    git rm --cached %имя_файла%
    
или 

    git restore --staged %имя_файла%

Чтобы сбросить файл до последнего сохранённого состояния (отменить внесённые изменения), нужно выполнить команду

    git restore %имя_файла%
    
Добавление новых файлов, переименование, перемещение файлов, удаление файлов, изменение содержимого файлов - все эти 
операции *являются изменением*. Соответственно, если пользователь желает зафиксировать эти изменения, все такие файлы 
должны быть явно проиндексированы. В том числе удалённые(перемещённые) - для текущего сохранённого состояния они ещё 
существуют, git о них "помнит".

В *IntelliJ IDEA* все изменения в имеющихся не-игнорируемых файлах индексируются автоматически. Включая перемещение, 
переименование, удаление файлов.  
Новые не-игнорируемые файлы - в зависимости от настроек *IDEA* - либо тоже автоматически индексируются, либо *IDEA* 
запрашивает решение у пользователя при создании файла в отслеживаемой директории.    
Если файл не проиндексирован, но его нужно добавить, сделать это можно рядом способов:  
(Необходимо, чтобы в дереве проекта был выбран нужный файл, либо открыт редактор нужного файла)
- верхнее меню => `VCS` => `Git` => `Add`;
- в дереве проекта `RMB` на нужном файле => `Git` => `Add`;
- в редакторе файла `RMB` => `Git` => `Add`;
- в диалоговом окне VCS (<code>Alt + \`</code>) => `Add to VCS`;
- горячие клавиши `Ctrl + Alt + A` (настраиваемы).

#### Фиксация изменений <a name="commit"></a>

**Фиксация изменений** - это фактическое сохранение текущего состояния проекта. При фиксации изменений **учитываются 
только проиндексированные изменения**. Таким образом пользователь может гибко определять, какие из произведённых 
изменений нужно зафиксировать.

Команда на фиксацию (сохранение) изменений:

    git commit

Фиксация изменений требует установки текстового комментария к сохранению, с кратким описанием сохраняемых изменений. 
Наличие комментария крайне полезно в дальнейшем: для понимания содержимого сохранения; для навигации по сохранённым 
состояниям, и т.д.  
Если в команде `git commit` комментарий не был указан, git откроет текстовый файл комментария в текстовом-редакторе по 
умолчанию для операционной системы. В нём необходимо установить комментарий, сохранить файл и закрыть редактор - тогда 
`commit` будет выполнен.

Комментарий удобнее указать сразу в команде на `commit` с помощью ключа `-m`:

    git commit -m "сообщение"
    
В результате операции в файлах локального репозитория git будет **сохранено текущее состояние проекта**: учтены все 
проиндексированные изменения. 
    
**Коммитом** (повсеместно употребляемый жаргонизм) называется как сама процедура *фиксации* изменений (чаще всего 
вместе с предварительной индексацией), так и сохранённое *состояние* проекта: очередной узел в хранимой истории 
изменений проекта.  
(Также часто употребляются производные жаргонизмы: *закоммитить*, *закоммиченный* и т.д.).

Коммиту присваивается уникальный идентификатор - хэш-сумма коммита: 40 шестнадцатеричных цифр. Например 
`a9ca2c9f4e1e0061075aa47cbb97201a43b0f66f`. Этот хеш (хеш-сумма) используется как "имя" (идентификатор) коммита во 
многих других командах git: при навигации по коммитам, слиянии коммитов от нескольких авторов, и т.д.  

Уникальность хеш-суммы не 100%-ная, но 16^40 вариантов - это настолько большое число, что вероятность совпадения хешей 
двух коммитов ничтожна.   
Более того, на практике для идентификации коммита зачастую используются только первые несколько (например, 8, 10 или 
16\) "цифр" хеша - git это позволяет, - и они почти наверняка будут уникальны для всех коммитов даже очень больших 
проектов. 

Удобная сокращённая команда 
    
    git commit -a "сообщение коммита"
    
заменяет собой две:

    git add *
    git commit -m "сообщение коммита"
    
т.е. проиндексировать все изменённые неигнорируемые файлы и сделать коммит с комментарием.  
Кстати, git позволяет использование нескольких команд подряд (в одной строке): их нужно просто указать через запятую.

В *IntelliJ IDEA* есть несколько путей сделать коммит:
- коммит *одного* файла:
    - в дереве проекта `RMB` на файле => `Git` => `Commit File ...`;
    - в открытом редакторе файла `RMB` => `Git` => `Commit File ...`;
    - (при фокусе на файле в дереве проекта / либо при открытом редакторе файла) в верхнем меню:
        `VCS` => `Git` => `Commit File...`;
    - (при фокусе на файле в дереве проекта / либо при открытом редакторе файла) вызвать диалоговое окно VCS 
        (<code>Alt + \`</code>) => `2. Commit File...`;
- коммит *нескольких* (в т.ч. и одного) файлов:
    - в верхнем меню: `VCS` => `Commit`;
    - в диалоговом окне VCS (<code>Alt + \`</code>) => `1. Commit...`;
    - горячими клавиами `Ctrl + K` (настраиваемые).

Во всех случаях будет открыто диалоговое окно коммита (с выбранным одним конкретным файлом, или всеми изменёнными 
неигнорируемыми файлами, соответственно), где пользователь может "галочками" выбрать какие конкретно файлы нужно 
сохранить; задать комментарий к коммиту; просмотреть сводку изменений в файлах; и подтвердить действие кнопкой `Commit` 
(или [`Commit and Push`](#push)).  
*IDEA* автоматически индексирует изменения для выбранных файлов, т.е. по факту `git add` и `git commit` всегда 
происходят вместе, нет необходимости отслеживать это дополнительно.

#### Просмотр истории коммитов <a name="log"></a>

Git хранит все сделанные коммиты в текущем проекте в виде цепочки. Каждый коммит (кроме самого первого) имеет ссылку на 
предыдущий коммит и хранит *разницу* между сохраняемым состоянием файлов и предыдущим коммитом.  
Таким образом, вся история проекта - это *цепочка* накопленных *разниц* между последовательными коммитами. Чтобы 
воссстановить всю историю проекта, необходимо к исходному состоянию (первому коммиту) последовательно применять эти 
*разницы*.

Последовательность коммитов исключительно важна: выпадение хотя бы одного коммита из цепочки, или нарушение порядка, 
приведёт к потере данных.

Коммит-предшественник называется **родителем** или **родительским коммитом**.  
Коммит, следующий за родителем называется **дочерним**.
Родительский коммит, родитель родителя и все предшествующие коммиты называются **предками** для текущего коммита.

Команда 

    git log
    
покажет историческую сводку по всем сделанным коммитам *в текущей [ветке](#branches)* репозитория от самого позднего 
(текущего) коммита до самого раннего (изначального) коммита. В записях истории указывается хеш коммита, автор, дата и 
комментарий.

История выводится постранично, навигация осуществляется управляющими клавишами, выход: `q`

    git log --all
    
покажет историю коммитов *во всех [ветках](#branches)*.

В *IntelliJ IDEA* история коммитов отображается в нижнем меню: `9: Version Control` (`Alt + 9`) => `Log`.  
Доступна фильтрация по свойствам коммита; поиск по хешу, по комментарию.    
По каждому из коммитов можно получить сводку изменённых файлов, в каждом из них получить изменения по сравнению с 
предыдущим или с текущим состоянием и прочее.
Здесь же осуществляется [навигация по коммитам](#navigation) с помощью контекстного меню (`RMB` по коммиту).

#### Об указателе `HEAD` <a name="head"></a>

Git хранит особую ссылку под названием `HEAD`. Ссылка `HEAD` указывает на тот коммит, который в данный момент считается 
выбранным / текущим / головой истории (хранит его хэш). 
Именно к коммиту, на который указывает `HEAD`, будет добавлен следующий сохранённый коммит.

В норме `HEAD` - это последний сохранённый коммит в текущей ветке, т.е. голова этой ветки. При добавлении нового 
коммита `HEAD`, конечно, обновляется.   
Но с помощью [навигации](#navigation) можно передвинуть указатель `HEAD`.

Поскольку за `HEAD` всегда скрывается просто ссылка на хэш конкретного коммита, `HEAD` *можно использовать* в качестве 
аргумента *во всех командах* git, где ожидается хэш коммита.

В *IntelliJ IDEA* ссылка `HEAD` также отображается в нижнем меню у конкретного коммита: 
`9: Version Control` (`Alt + 9`) => `Log` 

### Метки <a name="tags"></a>

Как уже описано, все коммиты идентифицируются своим хэш-кодом. Хэши большие и неудобны для запоминания. Git 
предоставляет возможность *пометить* любой коммит текстовой меткой.  

**Меткой** или **тегом** называется именованная ссылка на конкретный коммит в репозитории.  
Метка всегда указывает на один и тот же, конкретный коммит.  
Фактически, метка - это просто сокращённый, определённый пользователем идентификатор коммита, не более.

Команда

    git tag

покажет список всех имеющихся в репозитории меток (во всех ветках).

Команда 

    git tag %имя_тэга% 
    
пометит текущий коммит указанным именем. Текущий - это коммит, на который сейчас указывает `HEAD`.

Имя метки может быть любым, со следующими ограничениями: 
- используются только ASCII символы
- имя метки должно быть уникальным для данного репозитория 

Один и тот же коммит можно пометить сколько угодно раз.

Команда 

    git tag %имя_тэга% %хэш_коммита%
    
пометит указанный коммит указанным именем

Команда 

    git tag -d %имя_тэга%
    
удалит указанную метку. Удаляется только ссылка, сам коммит никак не задействован.

Поскольку за меткой всегда скрывается просто ссылка на хэш конкретного коммита, метки *можно использовать* в качестве 
аргумента *во всех командах* git, где ожидается хэш коммита. Собственно, метки только для этого и создаются.

В *IntelliJ Idea* все метки также отображается в нижнем меню у конкретного коммита: 
`9: Version Control` (`Alt + 9`) => `Log`  
Там же в контекстном меню (`RMB` на коммите) можно создать новый тэг или удалить имеющийся.  
Также контекстное меню меток можно открыть через верхнее меню => `VCS` => `Git` => `Tag...`

### Ветки <a name="branches"></a>

#### Определения <a name="branches-definitions"></a>

До сих пор описывалась линейная (последовательная) история изменений проекта (коммитов).  
На практике зачастую возникает необходимость изолированной работы над какой-то задачей без влияния на основной проект. 
Для этого используются **ветки** или **ветвления**.  

**Ветка** - это побочная, изолированная цепочка изменений (коммитов), начатая от некоторого имеющего состояния 
(коммита) проекта. Ветка идентифицируется своим именем.

Изначально проект в git имеет одну ветку: базовую, основную. Она создаётся по умолчанию и имеет имя **master**.

При необходимости пользователь может от какого-то коммита начать новую цепочку изменений: новую ветку, т.е. сделать 
ответвление. Ветка-источник ответвления называется **родительской**. Новая созданная ветка называется **дочерней**.  
Наиболее часто родительской веткой является *master*; ветки от веток создавать можно, но на практике это требуется 
нечасто.

Далее можно продолжать работу (добавлять коммиты) как в родительской ветке, так и в дочерней, независимо друг от друга. 
Обе ветки будут иметь общее прошлое: цепочку коммитов до момента ответвления. 
Но обе ветки будут иметь различное и независимое настоящее: цепочку коммитов с момента разветвления до головы ветки.

Как правило, ветка создаётся на основе текущего состояния master-ветки и используется для реализации какой-то отдельной 
задачи. После готовности задачи, изменения сделанные в дочерней ветке [переносятся](#merge) в master-ветку.  

#### Создание ветки <a name="create-branch"></a>

Список всех веток можно посмотреть командой

    git branch
    
будет выведен список всех имеющихся веток в репозитории и текущая выбранная (рабочая) ветка будет помечена `*`. 
Изначально есть только одна ветка - master.

Для создания новой ветки нужно использовать команду 

    git branch %имя_ветки%
    
Имя новой ветки может быть любым, со следующими ограничениями: 
- используются только ASCII символы
- имя ветки должно быть уникальным для данного репозитория 

Ответвление будет создано **от указателя `HEAD`**. Т.е. в норме (если `HEAD` [не сдвигали](#navigation)) ответвление 
создаётся от головы текущей ветки.

Фактически, ветка - это просто ссылка (указатель) на некоторый коммит, который является головой этой ветки. Эта ссылка 
показывает, куда должен прикрепляться следующий сделанный коммит в данной ветке (при коммите в ветку ссылка на голову 
ветки, конечно тоже обновляется).

До ответвления была только ветка master, которая указывала на последний сделанный коммит.  
После ответвления - существуют уже два указателя (ветки), но оба указывают на один и тот же последний коммит.
Далее, уже в зависимости от того, в какой ветке идёт работа, будет обновляться указатель соответствующей ветки и 
начнётся расхождение (разветвление) истории коммитов.

Обычно ответвления делают от головы текущей ветки, но при необходимости можно явно указать точку разветвления: команда
    
    git branch %имя_ветки% %хэш_коммита%
    
создаст указанное ответвление от указанного коммита.

Поскольку за именем ветки всегда скрывается ссылка на хэш конкретного коммита, имя ветки *можно использовать* в 
качестве аргумента *во всех командах* git, где ожидается хэш коммита.

В *IntelliJ IDEA* список имеющихся веток можно увидеть:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно);
- по горячим клавишам <code>Alt + Shift \`</code>

Там же можно создать новую ветку: `RMB` по ветке или коммиту => `New Branch...`  
и осуществлять все прочие действия с ветками.

#### Переключение между ветками <a name="checkout-branch"></a>

Команда `git commit` всегда добавляет изменения в текущую выбранную ветку. Предыдущая команда `git branch %имя_ветки%` 
только создала новую ветку; текущая ветка не изменилась - выбрана ветка master.

Для того чтобы добавлять изменения в другую ветку, на неё сначала нужно переключиться: сделать её текущей активной 
веткой. Для этого выполняется команда 

    git checkout %имя_ветки%
    
Git предостережёт от потери несохранённых локальных изменений: если есть незакоммиченные изменения, то команда 
`checkout` будет отменена. Эти несохранённые изменения можно закоммитить или [положить в stash](#stash).      
Переключение на выбранную ветку приводит проект к состоянию, сохранённому в коммите-голове этой ветки: откатываются все 
изменения до первого общего коммита-предка и применяются все коммиты выбранной ветки вплоть до последнего (до головы 
ветки).

Далее, работу, сделанную в этой ветке, можно сохранить обычным `git commit`.

В git есть сокращённая команда создания ветки и переключения на неё:

    git checkout -b %имя_ветки%
    
Эта команда равносильна выполнению подряд команд: 

    git branch %имя_ветки%
    git checkout %имя_ветки%

Этой же команде можно передать ещё один аргумент:

    git checkout -b %имя_ветки% %хэш_коммита%
    
где %хэш_коммита% указывает на конкретный коммит, где должно произойти ответвление. Тогда эта команда равносильна 
выполнению подряд:

    git checkout %хэш_коммита%
    git branch %имя_ветки%
    git checkout %имя_ветки%

В *IntelliJ IDEA* переключение между ветками можно осуществить:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно);
- по горячим клавишам <code>Alt + Shift \`</code>

#### Слияние веток <a name="merge"></a>

**Объединение** двух веток - это процедура обратная созданию ветки (разветвлению): изменения, накопленные в двух 
ветках, в результате *объединения* собираются в одной из них. Сами ветки при этом продолжают существовать.  
Две самых типичных задачи объединения:
- в master-ветке накопились изменения и нужно обновить побочную ветку до актуального состояния;
- по завершению работ в побочной ветке нужно доставить изменения в master-ветку.

Git поддерживает два существенно разных варианта объединения: *слияние* и *перебазирование*

**Слияние** (**merge**) - это процедура **явного** объединения двух веток, в результате которой **создаётся новый 
коммит, содержащий все изменения**, привнесённые из сливаемой ветки.  
(Также часто употребляются производные жаргонизмы: *мер(д)ж*, *смер(д)жить* / *замер(д)жить* и т.д.)

Синтаксис команды:

    git merge %имя_другой_ветки% 

Команда сливает изменения **из указанной** ветки (будем считать её побочной) **в текущую** активную ветку (будем 
считать её основной).

В результате действия merge **создаётся новый** особый **коммит** (может называться мердж-коммит), обладающий двумя 
предками: головой основной (текущей) ветки и головой побочной (сливаемой) ветки.  
Сам коммит **содержит всю разницу**, накопленную в побочной ветке, по сравнению с **текущим состоянием** (головой) 
основной ветки.  
Слитая побочная ветка остаётся неизменной: указатель её головы не смещается. Указатель головы основной ветки 
устанавливается на этот новый мердж-коммит. Другими словами, мердж-коммит принадлежит той ветке, **в** которую 
сливаются изменения (основной ветке). Активной (текущей) веткой остаётся так же основная ветка.

Родители мердж-коммита не равнозначны. Родительский коммит из той же ветки (основной) называется **первым родителем** и 
в командах [навигации по коммитам](#relative-links) считается родителем по умолчанию. Родительский коммит из 
сливаемой (побочной) ветки называется **вторым родителем**.

Если и основная и побочная ветка привнесли противоречащие изменения в один и тот же файл, процедура слияния породит 
[конфликт](#conflicts), который нужно будет разрешить, иначе слияние не будет выполнено (не будет завершено).

Если необходимо уравнять *обе ветки*, то нужно выполнить второе слияние, в обратную сторону:

    git checkout %имя_побочной_ветки%
    git merge %имя_основной_ветки%
    
т.е. переключиться в побочную ветку, и слить в неё изменение из (уже обновлённой) основной ветки. Новый коммит создан 
не будет: уже есть мердж-коммит содержащий изменения из обеих веток; просто указатель головы побочной ветки сдвигается 
на мердж-коммит.
В итоге каждая из веток "смотрят" на один и тот же коммит и каждая содержит все изменения, накопленные в обеих ветках.

Плюс процедуры merge в сохранении истории коммитов и явном наследовании коммитов.
Минус в том, что работа с множеством веток приведёт к созданию запутанного дерева из многочисленных разветвлений и 
объединений, в котором тяжело разобраться.

В *IntelliJ IDEA* слияние веток можно осуществить:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно работы с ветками);
- по горячим клавишам <code>Alt + Shift \`</code> (диалоговое окно работы с ветками).

#### Перебазирование веток <a name="rebase"></a>

**Перебазирование** - это процедура **перестройки дерева коммитов** таким образом, чтобы одна ветка **встроилась** в 
другую.

Синтаксис команды:

    git rebase %имя_целевой_ветки% 

Целевая ветка - это та ветка **куда** переносятся изменения; та ветка, которая будет **базисом** для перебазирования.
  
Команда переносит изменения **из текущей** ветки (будем считать её побочной) **в целевую** ветку (будем считать её 
основной), но делает это совершенно иным способом, чем мердж:
- Git анализирует дерево коммитов;
- находит последнего общего предка основной и побочной веток (то состояние, когда ветки были равнозначны в последний 
    раз); 
- затем берёт **всю цепочку коммитов** побочной ветки от общего предка до головы (до текущего состояния);
- и для каждого из них, в той же исторической последовательности:
    - создаёт коммит-копию
    - пытается применить его к голове основной ветки (как если бы этот коммит был сделан в основную ветку, но не 
        когда-то раньше, а сейчас);
    - в случае успеха сдвигает основную ветку на добавленный коммит.
- оригинальные коммиты побочной ветки, если на них не осталось ссылок, будут впоследствии уничтожены сборщиком мусора.

В итоге все отличающиеся коммиты побочной ветки последовательно применяются к основной ветке.

Можно сказать, что перебазирование работает как "машина времени".  
Все изменения, накопленные в побочной ветке - это последовательность коммитов, применённая к некоторому состоянию 
основной ветки в прошлом (к моменту ответвления). Перебазирование делает то же изменения, но не в прошлом, а в 
настоящем: применяет в той же последовательности цепочку тех же изменений, но стартует не с момента отделения, а с 
головы основной ветки.

Основная ветка остаётся неизменной: продолжает указывать на тот же коммит. Перебазированная побочная ветка указывает на 
последний перенесённый (скопированный) коммит.

Т.к. перестраивается последовательность коммитов, процедура перебазирования может породить дополнительные 
[конфликты](#conflicts), которые необходимо будет разрешить. Если и основная и побочная ветка привнесли противоречащие 
изменения в один и тот же файл, то так же как при мердже процедура перебазирования породит конфликт, который нужно 
будет разрешить. До разрешения всех конфликтов перебазирование не будет выполнено (не будет завершено).

Если необходимо уравнять *обе ветки*, то нужно выполнить второе перебазирование, в обратную сторону:

    git checkout %имя_основной_ветки%
    git rebase %имя_побочной_ветки%

Никаких переносов коммитов при этом уже не будет, в этом нет необходимости; просто указатель основной ветки 
переместится на тот же коммит, что и побочной ветки. 

Плюс процедуры rebase в удобной линейной истории коммитов.
Минус в том, что оригинальная история коммитов теряется (заменяется) и могут быть спровоцированы дополнительные 
конфликты.

В отличие от merge процедуру rebase можно выполнить находясь в третьей ветке (не основной, и не побочной). Для этого 
команда `rebase` может принимать ещё один аргумент:

    git rebase %имя_целевой_ветки% %имя_перебазируемой_ветки%
    
Аналогично, целевая ветка - это та ветка *куда* переносятся изменения, *базисом* для перебазирования; перебазируемая 
ветка - та ветка, *чьи* коммиты будут копироваться и переноситься на цель.

В результате перебазирования всегда активной веткой становится та ветка, что переносили (побочная). 

В *IntelliJ IDEA* перебазирование веток можно осуществить всё там же:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно работы с ветками);
- по горячим клавишам <code>Alt + Shift \`</code> (диалоговое окно работы с ветками).

#### Интерактивное перебазирование <a name="interactive-rebase"></a>

Перебазирование можно выполнить гибко: можно выбрать *какие именно* коммиты необходимо перебазировать на целевую ветку 
*и в какой последовательности*. Для этого нужно дополнительно указать ключ `-i` (от *interactive*).

    git rebase -i %имя_целевой_ветки% 

либо

    git rebase -i %имя_целевой_ветки% %имя_перебазируемой_ветки%
    
При этом будет инициирован диалог с пользователем, в ходе которого он должен будет отобрать перебазируемые коммиты из 
предложенных и установить порядок их применения. В остальном, процедура перебазирования происходит так же.

#### Отбор лучшего <a name="cherry-pick"></a>

Переносить коммиты из одной ветки в другую можно и совсем вручную. Для этого в git есть команда `cherry-pick`.  
Происходит от идиоматического выражения *cherry pick(-ing)* (буквально: выискивание ягод вишни), обозначающего 
внимательный отбор чего-то наилучшего.  
Наиболее близкое в русском языке: *отделить зёрна от плевел*.

Команда

    git cherry-pick %хэш_коммита1% %хэш_коммита2% %хэш_коммита3%

принимает набор **любых** коммитов (не ограниченное количество, не менее одного), и далее действует аналогично 
`rebase`: в указанной последовательности, для каждого из указанных коммитов:
- создаёт копию
- пытается применить её к голове **текущей** (активной) ветки 
- в случае успеха сдвигает основную ветку на добавленный коммит

Оригинальные указанные коммиты никак не затрагиваются (под сборщик мусора как при `rebase` не попадут).

Если среди указанных коммитов встречается тот, что уже принадлежит ветке, `cherry-pick` отменяется.  
Так же как и `rebase` может порождать конфликты, которые необходимо разрешить.

В отличие от слияния и перебазирования, `cherry-pick` позволяет добавить в текущую ветку **вообще любые** коммиты.

Плюс - в полной гибкости.  
Минус - в ответственности за свои действия.

В *IntelliJ IDEA* rebase веток можно осуществить всё там же:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно работы с ветками);
- по горячим клавишам <code>Alt + Shift \`</code> (диалоговое окно работы с ветками).

#### Редактирование веток <a name="branch-force"></a>

Поскольку ветка это всего лишь указатель (ссылка) на некий коммит, считающийся головой этой ветки, при необходимости 
её можно просто отредактировать.

Команда

    git branch -f %имя_ветки% %хэш_коммита%

устанавливает указатель заданной ветки на заданный коммит.

Аргумент никак не проверяется, можно указать любой существующий коммит, поэтому использовать команду нужно осмысленно: 
иначе можно "сломать" ветку.

#### Удаление ветки <a name="delete-branch"></a>

Более не нужную ветку можно удалить: например, после того как работы в ветке завершены и перенесены в родительскую 
ветку.

Команда 

    git branch -d %имя_ветки%
    
удаляет указанную ветку (т.е. указатель на голову данной ветки).  
Если ветка содержала невостребованные коммиты, и на них больше нет ссылок - эти коммиты впоследствии будут удалены 
сборщиком мусора.

Невозможно удалить:
- текущую выбранную (активную ветку);
- ветку master;
- то, что не является веткой.

В *IntelliJ IDEA* удалить ветку можно всё там же:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно работы с ветками);
- по горячим клавишам <code>Alt + Shift \`</code> (диалоговое окно работы с ветками).

### Навигация по истории коммитов <a name="navigation"></a>

#### Переключение на коммит <a name="checkout"></a>

Git позволяет переключить текущее состояние проекта на **любой** коммит, хранимый в репозитории. Для этого нужно 
выполнить команду

    git checkout %хэш коммита%
    
где хэш коммита можно предварительно узнать из `git log`.  
Также вместо хэша коммита можно указать метку (тег) или имя ветки.

Git предостережёт от потери несохранённых локальных изменений: если есть незакоммиченные изменения, то команда 
`checkout` будет отменена. Эти несохранённые изменения можно закоммитить или [положить в `stash`](#stash).    

При переключении (`checkout`) состояние проекта будет приведено к состоянию, сохранённому в указанном коммите.  
Указатель `HEAD` при этом тоже переключается на этот коммит.

Перенос указателя `HEAD` позволяет, например:
- создать новую ветку не от головы имеющейся ветки
- сделать новый коммит без создания ветки.

Если в качестве аргумента `checkout` указано имя ветки, git дополнительно переключит проект на указанную ветку.
Указатель `HEAD` при этом тоже переключается на указанный коммит, но т.к. этот же коммит будет головой указанной ветки, 
ничего нового в этом нет. 

В *IntelliJ IDEA* переключиться можно там же, в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`:
- `RMB` на интересующем коммите => `Show Repository At Revision` - только показать состояние репозитория на момент 
    указанного коммита; не переключаться на него;
- `RMB` на интересующем коммите => `Checkout Revision %хэш_коммита%` - перейти к указанному коммиту.

#### Относительные ссылки <a name="relative-links"></a>

Во всех рассмотренных командах выше в качестве аргумента _%хэш_коммита%_ передавался либо явный хэш-код коммита, либо 
некоторая ссылка, за которой тоже скрывается явный хэш код некоторого коммита.

Помимо прямых ссылок git поддерживает **относительные** ссылки, которые очень удобны при навигации.   
Относительная ссылка состоит из прямой ссылки и одного или нескольких *операторов*.

Оператор `~` обозначает **"получить родителя"** для применяемого аргумента. Т.е.`HEAD~` - указатель на предпоследний 
коммит в текущей активной ветке.  
Оператор `~` **может повторяться** сколько угодно раз: `HEAD~~~~` - указатель на четвёртого последовательного предка 
выше указателя `HEAD`.  
Оператор `~` имеет краткую форму `~n`, где `n` - некоторое число. `HEAD~4` - это тоже указатель на четвёртого предка 
для `HEAD`.

Оператор `^` тоже означает **"получить родителя"** для применяемого аргумента, но в случае [мердж-коммитов](#merge) 
позволяет выбрать **какого именно родителя**:
- `^1` - выберет первого родителя (того, что был в той же ветке, что и мердж-коммит); значение по умолчанию;
- `^2` - выберет второго родителя (из сливаемой ветки);
- `^` без указания - равносильно `^1`.

Оператор `^` тоже **может повторяться** сколько угодно раз. Краткой формы не имеет.

Операторы относительных ссылок **можно применять к любым** формам ссылок: хэшам коммитов, меткам, веткам, указателю 
`HEAD`.  
Операторы относительных ссылок **можно произвольно комбинировать**, например, указатель `feature~4^2^^~~` означает:
- взять хэш-код головы ветки `feature`;
- перейти на 4 родителя выше;
- перейти ко второму родителю;
- перейти ещё на 4 родителя выше (в разной форме).

### Редактирование истории <a name="editing"></a>

#### Сброс коммита <a name="reset"></a>

Несмотря на важность последовательности коммитов, git предоставляет пользователю ряд инструментов, которыми можно на 
неё повлиять. Например, для случаев, когда коммит содержит ошибку или был сделан по ошибке. И необходимо исправление.

Самый очевидный вариант: сделать исправления вручную и сделать новый коммит, исправляющий неправильный, но git обладает 
и другими инструментами. 

Состояние проекта можно **сбросить** до какого-то коммита. Командой `git log` можно получить историю 
коммитов, получить хэш интересующего коммита. Команда

    git reset --hard %хэш_коммита%
    
**сбросит** текущую ветку до состояния, хранимого в указанном коммите. Все изменения, сделанные после - **будут 
отменены**. 
Все коммиты, следующие по цепочке наследования за указанным коммитом - будут более "не видны". Если на них не осталось 
ссылок - они **будут уничтожены** сборщиком мусора.

Команда `git reset --hard` необратима, использовать её нужно с большой осторожностью.

В *IntelliJ IDEA* сброс коммита можно осуществить в нижнем меню `9: Version Control` (`Alt + 9`) => `Log` => `RMB` на 
интересующем коммите => `Reset Current Branch to Here`.

#### Отмена коммита <a name="revert"></a>

Команда 

    git revert %хэш_коммита% 
    
создаёт **новый** коммит, содержание которого полностью **противоположно** указанному коммиту, и пытается применить 
его к текущему состоянию проекта. То есть команда `git revert` *инвертирует* указанный коммит.  
Если проект успел измениться с тех пор, когда был сделан инвертируемый коммит, инверсия может быть неудачной (не 
сможет примениться). Это создаст конфликт, который будет необходимо разрешить вручную.

Наиболее употребима инверсия последнего коммита. Для этого удобно использовать команду в форме

    git revert HEAD

В *IntelliJ IDEA* отмену коммита можно осуществить в нижнем меню `9: Version Control` (`Alt + 9`) => `Log` => `RMB` на 
интересующем коммите => `Revert Commit`. 

#### Редактирование коммита <a name="amend"></a>

Предыдущие варианты либо удаляли неверный коммит, либо создавали новый коммит исправлением.

Команда 

    git commit --amend -m "%текст_комментария%"

позволяет именно **отредактировать последний** сделанный коммит. Фактически, эта команда **заменяет** последний 
сделанный коммит на новые сохраняемые изменения.  
Отредактировать можно **только последний коммит**, нельзя указать хэш конкретного коммита для редактирования. 

Git хранит последний использованный комментарий. Если необходимо сделать коммит с тем же сообщением, например, при 
редактировании коммита, можно указать ключ `--no-edit`. Команда

    git commit --amend --no-edit
    
Выполнит редактирование последнего коммита без вызова редактора файла комментария, будет использован сохранённый 
комментарий - последний использованный. 

### Сокрытие изменений <a name="stash"></a>

Сделанные локальные изменения не всегда готовы к тому чтобы их сохранять (коммитить), но при этом может потребоваться 
переключиться на другую ветку или другой коммит. При наличии несохранённых изменений, переключение через `checkout` 
куда-либо - невозможно.
   
Git позволяет скрыть текущие сделанные локальные изменения: сохранить их и отложить "на полку" (в `Stash`), без 
создания коммита.

Команда 
    
    git stash

либо

    git stash save

создаёт новую запись в `stash` и сохраняет туда все текущие незакоммиченные изменения.  
Записи присваивается индекс 0. Всем остальным ранее сокрытым изменениям индекс сдвигается на единицу вперёд.
   
Команда 

    git stash list
    
показывает список всех записей в `stash`.  
Самое последнее сокрытие имеет индекс 0. Чем выше индекс - тем более раннее это сокрытие.

Команда 

    git stash apply

возвращает последнее сокрытие (с индексом 0) и пытается его применить к текущему состоянию проекта. Само сокрытие из 
`stash` при этом не удаляется.    
Может породить [конфликты](#conflicts).

Команда 

    git stash pop
    
действует аналогично `git stash apply`, но после удачного применения ещё и удаляет сокрытие из `stash`.

Можно указать индекс какое конкретно сокрытие нужно применить:

    git stash apply stash@{7}
    git stash pop stash@{7}

применит сокрытие с индексом 7 (точнее, с индексом `stash@{7}`).

Команда

    git stash drop stash@{n}
    
удалит сокрытие с указанным индексом из `stash`. Все последующие индексы будут соответственно смещены назад.  
Если не указать индекс:

    git stash drop
    
будет удалено самое недавнее сокрытие (с индексом 0).

Наконец, команда 

    git stash clear
    
очистит все сокрытия.

В *IntelliJ IDEA* работа с сокрытиями осуществляется:
- в верхнем меню `VCS` => `Git` => `Stash Changes...` или `UnStash Changes...`; 
- в диалоговом окне VCS (<code>Alt + \`</code>) => `9. Stash Changes...` или `0. UnStash Changes...`
для осуществления сокрытия и применения (возвращения) сокрытого соответственно. 

В обоих случаях используется диалоговое окно, где пользователь может задать комментарий к сокрытию, выбрать индекс, 
выбрать действие: просмотреть, применить, применить и удалить, удалить, очистить.

### Конфликты <a name="conflicts"></a>

Текстовые файлы git отслеживает построчно; в коммитах вычисляет и хранит разницу именно в содержимом строк. 
Бинарные файлы (изображения, медиа, архивы и т.д.) git отслеживает целиком, как поток байт.

**Конфликт** или **конфликтная ситуация** возникает, когда применяемый коммит содержит изменения не совместимые с 
текущим состоянием проекта; когда git определяет наличие **двух изменений** одной и той же сущности, **противоречащих** 
друг другу.    
В случае текстовых файлов противоречие определяется на уровне отдельных строк; в бинарных файлах - на уровне файла 
целиком. 

**Разрешением** конфликта называется явный выбор значения для сущности, вызвавшей конфликт (строки или файла).  
Git всегда оставляет разрешение конфликта за пользователем. Пользователь сам должен определить, какой из двух вариантов 
противоречащих изменений должен быть оставлен, либо установить третий, промежуточный, объединяющий вариант. 

Наиболее часты причины возникновения конфликта:
- применение коммита (или сокрытия) при наличии несохранённых локальных изменений:
    - строка файла была локально изменена, по сравнению с последней сохранённой версией
    - применяемый коммит или сокрытие пытается изменить эту же строку.
- применение коммита (или сокрытия), противоречащего накопленным изменениям в текущей ветке:
    - ведётся работа в текущей ветке, сделаны коммиты
    - применяется коммит (из любого источника) или сокрытие
    - или локальный репозиторий обновляется из удалённого до актуального состояния (т.к. удалённый репозиторий был 
        обновлён, другим пользователем, например)
    - текущие накопленные изменения противоречат пришедшим изменениям в коммите (сокрытии).
- объединение веток (`merge`, `rebase` или `cherry-pick`):
    - коммиты в объединяемых ветках пытаются изменить одину и ту же строку (файл).

Каждый раз при возникновении конфликта:
- текущая команда git не завершается
- во всех файлах с противоречиями, на соответствющих строках git создаёт записи вида

<!-- -->
    <<<<<<< 6f411d1e00a61443c1a6fc459822d562fdc44e99
    some text
    =======
    Some conflicted text
    >>>>>>> 38508657ad15813900300a8896a51cfa1631be16
<!-- -->

где указывает оба противоречащих варианта нового значения данной строки с указанием хэша коммита, откуда эти изменения 
пришли.

Пользователь должен в явном виде **разрешить** каждый такой конфликт, прежде чем git-команда завершится и можно будет 
продолжать работу. **Для разрешения** конфликта нужно **установить конечное содержимое файла** с учётом того, что 
пользователь хочет сохранить. Для этого, как минимум, необходимо представленный текст конфликта заменить на некоторое 
(любое) финальное значение: пользователь либо выбирает один из двух предложенных вариантов, либо создаёт третий 
вариант, объединяющий  оба изменения. Разрешить нужно *все* конфликты.

В *IntelliJ IDEA* разрешение конфликтов проводится в удобном графическом интерфейсе, где представлены текущее состояние 
файла и оба предлагаемых состояния файла (из каждого из источников), с подсвеченной разницей между файлами. 
Пользователь может по каждой разнице соответствующими кнопками применить или отбросить предлагаемое изменение из любого 
источника, либо явно редактировать локальную текущую версию файла. 

### Удалённые репозитории <a name="remotes"></a>

До сих пор речь шла про локальное сохранение изменений, сделанное одним пользователем. Перейдём к работе с удалённым 
репозиторием.  
Удалённый репозиторий используется для:
- резервного копирования данных;
- распространения исходного кода другим пользователям;
- хранения главной (общей, стабильной) версии кода (в то время как в локальном репозитории ведётся работа над текущими 
    задачами);
- синхронизации локальных репозиториев различных пользователей;
- объединения изменений, сделанных различными пользователями.

Фактически, удалённый репозиторий - это ещё один такой же git-репозиторий, действующий по тем же правилам: так же 
хранит состояния проекта (коммиты), так же обновляется через коммиты, и т.д.

Для дальнейшей работы удалённый репозиторий должен существовать. 
Простейший способ создания удалённого репозитория - клонирование.

#### Клонирование репозитория <a name="clone"></a>

**Клонирование** репозитория - это процедура создания полной копии для клонируемого репозитория. Оригинальный 
репозиторий станет **удалённым** репозиторием для созданного клона.  

Оба репозитория могут располагаться физически на одном компьютере, но чаще удалённый репозиторий располагается на 
некотором сетевом ресурсе, например, на GitHub. На GitHub новый репозиторий можно легко создать в web-интерфейсе 
пользователя.

Для клонирования проекта из удалённого репозитория (локально проекта ещё нет) используется команда 

    git clone %URL%
    
Выполнять команду необходимо в директории будущего склонированного проекта. А в качестве `%URL%` указать:
- путь до клонируемого репозитория (если он располагается на том же компьютере)
- или сетевую ссылку (URL) клонируемого репозитория, например `https://github.com/jjd-ifmo/lessons.git`

В результате директории, где была вызвана команда, будет создан локальный git-репозиторий, наполненный скопированными 
данными. Полученный проект можно затем скопмилировать и запустить.

В *IntelliJ IDEA* создать новый проект путём клонирования из удалённого репозитория можно:
- В верхнем меню: `File` => `New` => `Project From Version Control`;
- В верхнем меню: `VCS` => `Git` => `Clone...`.

В обоих случаях откроется диалоговое окно клонирования проекта из системы контроля версий, где нужно указать `URL` 
репозитория (либо выбрать существующий репозиторий на GitHub) и указать путь до директории создаваемого проекта.  
Далее нужно пройти через стандартные этапы создания проекта в *IDEA*.

После завершения клонирования проект, возможно, необходимо будет настроить (некоторые настройки могут произойти 
автоматически):
- выбрать директорию с исходным кодом: в дереве проекта `RMB` по директории с исходным кодом (обычно `src`) => `Mark 
    Directory as` => `Sources Root` (директория должна подсветиться голубым цветом).
- далее в настройках проекта `File` => `Project Structure` => вкладка `Project` (или горячие клавиши 
`Ctrl + Alt + Shift + S): 
    - выбрать `Project SDK (JDK)`: выбрать необходимую версию платформы Java из установленных на компьютере.  
        Она не должна быть ниже, чем версия языка, на котором написан склонированный проект, иначе нет гарантии его 
        работоспособности.
    - выбрать `Project language level` - уровень языка для *IDEA*. Используется в проверках, подсветках, подсказках 
        производимых *IDEA* в помощь пользователю.  
        Он не должен быть выше версии JDK.
    - выбрать `Project compiler output` - директорию для скомпилированных класс-файлов. Обычно `./out/`  

#### Связь локального репозитория с удалённым <a name="remote-add"></a>

Иная ситуация, когда два git-репозитория уже существуют, и нужно один из них сделать удалённым репозиторием ко второму.
Например, есть локальный репозиторий для работы на текущем компьютере; и пустой репозиторий, созданный на GitHub.

Для связи локального репозитория с удалённым необходимо в рабочей директории проекта (локально) выполнить команду:

    git remote add %name% %URL%

Эта команда указывает *локальному* репозиторию направление на привязанный к нему удалённый репозиторий.   
Здесь `%name%` - это *имя*, которое локальный репозиторий присваивает привязанному удалённому репозиторию. В дальнейшем 
удалённый репозиторий будет идентифицироваться этим именем. Имя может быть любым (допускается латиница, должно быть 
уникально для данного репозитория), но принято главный удалённый репозиторий называть `origin`.  
Далее, `%URL%` здесь это сетевая ссылка (URL) до нужного удалённого репозитория, например 
`https://github.com/SlepuhinAlexander/tst-git.git`.

У одного удалённого репозитория может быть множество привязанных к нему локальных репозиториев (например, на 
компьютерах всех участников проекта). Чтобы привязать второй локальный репозиторий к этому же удалённому, необходимо в 
месте расположения второго локального репозитория выполнить эту же команду с той же ссылкой и именем.

Наоборот, у одного локального репозитория тоже может быть привязано множество удалённых репозиториев (например, для 
резервного копирования). Для привязывания второго удалённого репозитория нужно выполнить эту же команду, но уже с новым 
именем для удалённого репозитория и соответствующей ссылкой. 

Связь локального репозитория с удалённым - однократная процедура. В дальнейшем производится синхронизация локального 
репозитория с удалённым: [отправка локальных изменений](#push) (`push`); [обновление локальной версии до общей](#pull) 
(`pull`).

Удалить связь локального репозитория с удалённым (если она больше не нужна) можно командой

    git remote remove %имя%

где в качестве `%имя%` указать имя удалённого репозитория заданное при связке. Например: `git remote remove origin`

Команда

    git remote
    
выдаст список имён всех удалённых репозиториев, привязанных к данному локальному репозиторию.

Команда

    git remote -rm %имя_репозитория%
    
удалит **связь** локального репозитория с указанным удалённым репозиторием. Сам удалённый репозиторий и все его коммиты 
не будут затронуты.

В *IntelliJ IDEA* добавление / удаление / редактирование связей с удалёнными репозиториями расположено в диалоговом 
окне `Git Remotes`, которое можно открыть из верхнего меню: `VCS` => `Git` => `Remotes`.

#### Отправка изменений в удалённый репозиторий <a name="push"></a>

**Отправка изменений в удалённый репозиторий** называется `push` (от названия команды `git push`; так же 
встречаются жаргоризм "пуш" и его производные: "запушить", "запушенный" и т.д.).

Единицей изменений при передаче между репозиториями является *коммит*: для того, чтобы отправить изменения файлов в 
удалённый репозиторий их нужно сперва сохранить (закоммитить) в локальный репозиторий.

При пуше в удалённый репозиторий будут отправлены **все** (ранее не запушенные) коммиты текущей ветки, одним действием.

Общий вид команды

    git push %имя_репозитория% %имя_ветки%

где в качестве `%имени_репозитория%` нужно указать имя привязанного удалённого репозитория; а `%имени_ветки%` - имя 
целевой [ветки](#branches) в этом удалённом репозитории.
     
например

    git push origin master
    
здесь `origin` - имя основного удалённого репозитория; `master` - имя основной ветки в целевом репозитории (ветка 
`master` в любом репозитории создаётся по умолчанию).

При этом может потребоваться ввод логина-пароля от удалённого репозитория (от учётной записи на GitHub в данном 
случае).

Краткая форма записи

    git push
    
использует *текущее сохранённое* значения для `%имени_репозитория%`, а в качестве`%имени_ветки%` использует текущую 
активную ветку.  
Установить / обновить сохранённые значения (вместе с пушем) можно при помощи ключа `-u`, например:

    git push -u origin master

В результате пуша в удалённом репозитории будет сделан тот же набор коммитов, что и объединяющий все отправляемые 
изменения.

В *IntelliJ IDEA* отправку изменений (`push`) можно сделать:
- сразу вместе с [коммитом](#commit);
- в верхнем меню: `VCS` => `Git` => `Push...`
- в диалоговом окне VCS (<code>Alt + \`</code>) => `8. Push...`;
- горячими клавишами `Ctrl + Shift + K` (настраиваемые).

Будет открыто диалоговое окно `Push Commits` со сводкой по коммитам, готовым к отправке. В каждом из коммитов можно 
посмотреть список файлов, автора, дату, комментарий, и т.д. Подтвердить действие нужно кнопкой `Push`.

Удалить ранее отправленную ветку в удалённом репозитории можно командой

    git push origin %имя_репозитория% --delete %имя_ветки%
    
Результат будет аналогичен [удалению ветки](#delete-branch) в локальном репозитории.

При отправке в удалённый репозиторий ветки (в т.ч. ветки мастер), если этой ветки ещё не было в удалённом репозитории:
- в удалённом репозитории *создаётся ветка* с тем же именем.
- в неё копируются переданные коммиты
- в локальном репозитории *создаётся новая ветка* с именем `%имя_репоизтория%/%имя_ветки` (например, `origin/master`)
- эта новая ветка устанавливается на тот же коммит, что является головой удалённой ветки в удалённом репозитории.

Эта ветка `%имя_репоизтория%/%имя_ветки` является отражением в локальном репозитории ветки `%имя_ветки%` из удалённого 
репозитория. Её задача в отслеживании состояния удалённой ветки.

В *IntelliJ IDEA* работать с ветками удалённого репозитория можно:
- в нижнем меню `9: Version Control` (`Alt + 9`) => `Log`;
- в верхнем меню `VCS` => `Git` => `Branches...` (диалоговое окно работы с ветками);
- по горячим клавишам <code>Alt + Shift \`</code> (диалоговое окно работы с ветками).

#### Выкладка проекта в удалённый репозиторий <a name="export"></a>

В *IntelliJ IDEA* есть удобная интеграция с GitHub, с её помощью можно практически в одно действие проект, находящийся 
под контролем git локально, выложить целиком на GitHub (минуя этапы создания удалённого репозитория, связывания с ним 
локального и т.д.).

Фактически, это операция противоположная клонированию: из *локального* репозитория создаётся связанный *удалённый* 
репозиторий-клон.

В верхнем меню: `VCS` => `Import Into Version Control` => `Share Project on GitHub`. В открывшемся диалоговом окне 
нужно ввести логин-пароль от аккаунта на GitHub, а далее указать имя удалённого репозитория (по умолчанию origin), 
название репозитория на GitHub и, опционально, описание.

В результате будет создан выбранный удалённый репозиторий на GitHub, он же будет связан с текущим локальным 
репозиторием и *IDEA* выполнит `git push` всех коммитов текущей ветки.

Таким образом, на GitHub появится полная копия выложенного проекта (за исключением файлов, указанных в `.gitignore`).

#### Получение изменений из удалённого репозитория <a name="fetch"></a>

Обратная операция к `git push` - это получение текущего состояния удалённого репозитория (его ветки). Например, 
состояние удалённого репоизтория могло обновится, если туда был сделан пуш из другого репозитория (от другого 
пользователя).

Команда 

    git fetch %имя_репозитория% %имя_ветки%
    
где `%имя_репозитория%` - имя удалённого репозитория, `%имя_ветки%` - имя удалённой ветки в удалённом репозитории.
Команда `git fetch` **скачивает** все изменения, которые могли накопиться в репозитории `%имя_репозитория` в ветке 
`%имя_ветки%` и **применяет их к ветке `%имя_репозитория%/%имя_ветки%`**, т.е. к локальному отражению удалённой ветки.  
Локальные ветки при `git fetch` никак не затрагиваются, состояние проекта остаётся неизменным.

Скачанные изменения пользователь может потом объединить с соответствующей локальной веткой с помощью [`merge`](#merge) 
или [`rebase`](#rebase).

Команда 

     git fetch
     
без аргументов скачивает **все** новые изменения из удалённого репозитория **из всех веток**, и аналогично, применяет 
их к соответствующим локальным отражениям удалённых веток.

В *IntelliJ Idea* скачивание изменений из удалённого репозитория можно осуществить в верхнем меню 
`VCS` => `Git` => `Fetch`.  

#### Синхронизация локального репозитория с удалённым <a name="pull"></a>

Процедуры скачивания изменений из удалённого репозитория (`git fetch`) и объединения их с локальными ветками 
(`git merge` / `git rebase`) git позволяет объединить в одном действии: `git pull`.

Обратная операция к `git push` - это получение текущего состояния удалённого репозитория и применение его к локальному.  
Операция называется `pull` (от названия команды `git pull`; так же встречаются жаргонизм "пул(л)" и его производные: 
"запул(л)ить", "запул(л)еный" и т.д.).

Синтаксис команды:

    git pull %имя_репозитория% %имя_ветки%
    
где в качестве `%имени_репозитория%` указывается имя удалённого репозитория (обычно - `origin`), а в качестве 
`%имени_ветки%` - имя интересующей ветки в нём (часто - `master`).

Команда выполняет [скачивание](#fetch) (если нужно) и затем [слияние](#merge) ветки-отражения 
`%имя_репозитория%/%имя_ветки%` в локальную ветку `%имя ветки%`

То есть выполнение

    git pull origin master
    
равносильно последовательному выполнению

    git fetch origin maser
    git checkout maser
    git merge origin/master
    
Как и при обычном [слиянии](#merge), при необходимости будет создан новый мердж-коммит, сливающий изменения двух веток.

Объединять ветки можно не только с помощью слияния, но и с помощью [перебазирования](#rebase). В работе с удалёнными 
репозиториями это тоже справедливо. Чтобы синхронизация с удалённым репозиторием использовала `rebase` вместо `merge` в 
команду `git pull` нужно добавить ключ `--rebase`:

    git pull --rebase %имя_репозитория% %имя_ветки%
    
В таком случае после скачивания изменения в ветку отражение `%имя_репозитория%/%имя_ветки%`, **на неё** будет 
**[перебазирована](#rebase)** локальная ветка `%имя ветки%`

То есть выполнение

    git pull --rebase origin master
    
равносильно последовательному выполнению

    git fetch origin master
    git rebase origin/master master
    git checkout master  

Краткая запись 

    git pull
    git pull --rebase
    
использует основной удалённый репозиторий (`origin`) и имя текущей активной ветки.

В *IntelliJ IDEA* синхронизацию (`pull`) можно сделать:
- в верхнем меню: `VCS` => `Git` => `pull` (с выбором репозитория / ветки для обновления);
- в верхнем меню: `VCS` => `Update Project...` (со значениями репозитория / ветки по умолчанию);
- горячими клавишами `Ctrl + T` (настраиваемые). 
