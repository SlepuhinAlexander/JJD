## Основы git

**Система управления версиями** (Система контроля версий, Version Control System, VCS) - программное обеспечение для 
облегчения работы с изменяющейся информацией. Система управления версиями позволяет хранить множество различных 
**состояний** (версий) одного и того же файла; отслеживать изменения в файлах; авторство и последовательность 
изменений; возвращаться к более ранним версиям; объединять множественные изменения одного и того же файла, сделанные 
различными авторами.   
Системы управления версиями повсеместно используются в разработке программного обеспечения для хранения исходных кодов 
программ и отслеживания их изменений.

**Состояние** проекта - это набор всех файлов, находящихся под управлением VCS, и их текущее содержимое (состояние). 
Каждый раз, когда фиксируется (сохраняется) 

**Репозиторий** - хранилище для документов под контролем системы управления весиями, истории их изменения и прочей 
служебной информации. Репозиторий может быть: 
- **локальным** - расположенным на компьютере пользователя (разработчика) и, соответственно, доступный только ему;   
    обычно используется для хранения текущих правок, временных рабочих версий файлов;  
- **удалённым** - расположенным на сервере в информационной сети;   
    к удалённому репозиторию обычно есть доступ у множества пользователей (разработчиков);  
    он используется для публикации изменений, сделанных локально, - в общий доступ для всех пользователей проекта; 
    хранения общей рабочей версии кода; объединения правок, сделанных каждым из пользователей в одну рабочую версию; 
    обновления локальных репозиториев до актуальных версий файлов проекта.

**Git** - распределённая управления версий, которая даёт возможность разработчикам отслеживать изменения в файлах 
исходного кода и работать совместно (параллельно) с другими разработчиками над одними и теми же файлами.  
Git является одной из самых популярных VСS в коммерческой разработке и используется практически повсеместно.  
Гит является *распределённой* VCS, т.к. позволяет создавать и локальные и удалённые репозитории, связанные между 
собой.  

**GitHub** - это бесплатный сервис, предоставляющий серверные мощности для хранения в сети пользовательских удалённых 
репозиториев на базе git.  
Зачастую *GitHub* используется для резервного хранения файлов исходного кода пользователей; обмена такими файлами между 
пользователями; проектами с открытым кодом (open source), в которых может принять участие любой сторонний пользователь.  

### Настройка git

Первоначальную настройку git достаточно выполнить один раз. Для начала необходимо указать имя пользователя git и его 
электронную почту. Эти данные будут использоваться как подпись автора сделанных изменений при сохранении состояния 
проекта в git. Данные можно указать любые.

Команды:

    git config --global user.name
    git config --global user.email

*считывают* и отображают текущее значение параметров пользователя `user.name` и `user.email`

Команды
       
    git config --global user.name "Your Name"
    git config --global user.email "your_email.@whatever.com"
    
*устаналивают* значения параметров пользователя `user.name` и `user.email` в `Your Name` и `your_email.@whatever.com` 
соответственно.

Ответной реакции на установку новых значений нет. Чтобы проверить установленные значения можно запросить их ещё раз.

Ключ `--global` указывает, что настройка устанавливается для текущего пользователя операционной системы. Ещё варианты: 
- не указывать ключ после `config`: параметры будут считаны / установлены для конкретного проекта;
- указать ключ `--system` вместо `--global`: параметры будут считаны / установлены для всех пользователей операционной 
   системы. 


При необходимости, изменить настройки можно позже, теми же командами. 

### Инициализация git-репозитория

Для подключения имеющегося проекта к системе управления версиями, нужно провести инициализацию git-репозитория. 
Инициализация - это создание репозитория и его первичная настройка.

Перед этим необходимо определить место хранения файлов git, относящихся к интересующему проекту. Обычно для этого 
используют корневую директорию проекта.  
Необходимо перейти в директорию проекта, команда(ы)

    cd %путь_до_директории_проекта%
    
Находятсь в директории проекта, для инициализации git-репозитория необходимо выполнить команду

    git init

В результате в целевой диретории появляется скрытая директория .git - это и есть место хранения локального 
git-репозитория. Теперь все файлы (во всех директориях, включая вложенные) проекта - находятся под контролем git. Git 
теперь может отслеживать изменения в файлах проекта и сохранять текущее состояние проекта по запросу.

В среде *IntelliJ IDEA* создать новый git-репозиторий можно:
- вызвав всплывающее меню работы с VSC (<code>Alt + \`</code>), и выбрав `1. Create Git Repository...`
- из верхнего меню: `VCS` => `Import Into Version Control` => `Create Git Repository...`

### Исключения из-под контроля версий

Далеко не все файлы проекта бывает необходимо хранить под контролем версий. Обычно, под версионным контролем хранят 
файлы исходного кода, и ресурсные файлы проекта (медиа, изображения, и.т.д.). Нет необходимости сохранять (и делиться 
ими с коллегами) файлы настроек проекта, скомпилированные класс-файлы.

Для того чтобы исключить файлы и / или директории из-под контроля версий git, их необходимо указать в специальном файле 
с `.gitignore`.

В корневой папке проекта (точнее, в папке, где был проинициализирован git-репозиторий) необходимо создать файл с именем 
`.gitignore` и в этом файле перечислить пути до файлов / директорий, которые git должен игнорировать. Например:

    /.idea/
    /out/
    /JJD.iml

Отдельная строчка для каждой новой записи. Если указана директория - то игнорироваться будет всё содержимое директории 
включая вложенные директории.   
Пути обычно указываются относительные: относительно директории проекта. Символ `/` в начале строки указывает на 
содержание в текущей директории (директории проекта). Он не обязательный, можно опустить.
Можно использовать маски `*` для замены любых символов (в любом количестве), например запись: `/res/*.jpg` добавит в 
исключения все файлы с расширением `.jpg` в директории `res/` в корне проекта. 

Обычно в `.gitignore` добавляются:
- все файлы `.idea/` - это служебные файлы, которые генерирует сама *IntelliJ IDEA* для работы с проектом.
- все файлы `out/` - скомипилированные класс-файлы. В зависимости от настроек проекта путь для компиляции класс-файлов 
    может отличаться.
- _%имя_проекта%_.iml и прочие файлы настройки проекта (если есть).

Сам файл `.gitignore` должен оставаться под версионным контролем (чтобы другие пользователи могли использовать его же).
Т.е. добавлять `.gitignore` в `.gitignore` не нужно.

В *IntelliJ IDEA* добавить файлы в `.gitignore` можно так же, прописав их в этом файле вручную, а можно из контекстного 
меню: `RMB` на файле или директории в дереве проекта => `Git` => `Add to .gitignore`.

Все файлы, указанные в `.gitignore` будут проигнорированы git. Никакие изменения в них отслеживаться не будут, их 
состояние сохраняться в git не будет.

### Отслеживание изменений

Git автоматически отслеживает все изменения, произошедшие в файлах, находящихся под версионным контролем.  
Новые созданные файлы в отслеживаемых директориях также попадают под версионный контроль. В том числе, все 
неигнорируемые файлы, как только был создан репозиторий - считаются новыми добавленными файлами.

Фактически, git отслеживает именно файлы (и пути до них), директории отслеживаются косвенно: если директория под 
версионным контролем, но пуста, то git про неё ничего "не знает".

Команда 

    git status
    
позволяет получить сводку по всем изменениям в отслеживаемых файлах по сравнению с последним сохранённым состоянием.
В ней указываются новые файлы, добавленные под версионный контроль; удалённые, перемещённые, переименованные файлы; 
файлы, в которых были сделаны изменения.

В *IntelliJ IDEA* статус файлов проекта динамически отображается в дереве проекта (цвета - настраиваемые):
- голубой: изменённые файлы
- красный: новые непроиндексированные (см. ниже) файлы;
- зелёный: новые проиндексированные (см. ниже) файлы.
- тёмно-зелёный - игнорируемые файлы.

А общая сводка текущих локальных изменений доступна в нижнем меню: `Version Control` (`Alt + 9`) => `Local Changes`. 

### Индексация изменённых файлов

**Сохранение** состояния проекта в git состоит из двух этапов:
- индексация изменённых файлов
- фиксация изменений

**Индексация изменений** - это операция при которой git вычисляет (и подготавливает к сохранению) разницу между текущим 
состоянием файла и известным ему сохранённым состоянием файла (если оно было).

Индексация изменений *обязательна*, для того чтобы git мог сохранить обновлённое состояние. Непроиндексированные 
изменения сохранены *не будут*. Соответственно, пользователь сам должен определить какие из изменений (какие файлы) 
необходимо сохранить, а какие - нет.

Индексация производится командой 

    git add %имя_файла_или_директории%
    
В качестве %имени_файла_или_директории% указывается полный или относительный (относительно текущей директории) путь до 
файла или директории, изменения в которой необходимо проиндексировать.  
Если файл / директория находятся в текущей директории, достаточно указать только имя.  
Добавление директории проиндексирует все неигнорируемые файлы в этой директории.  
Можно использовать маски `*` для замены любых символов (в любом количестве), например: `git add res/*.jpg` 
проиндексирует изменения во всех файлах с расширением `.jpg` в директории `res/` в корне проекта.  

Файлы / директории командой `git add` добавляются по одному. Команду `git add` необходимо применить ко всем файлам, 
которые нужно сохранить. Возможности указать несколько аргументов - нет.

Команда 

    git add *
    
проиндексирует вообще все сделанные изменения в неигнорируемых файлах.

Повторив команду `git status` можно увидеть сводку, какие изменённые файлы проиндексированы (и готовы к сохранению), а 
какие - нет и сохранены не будут.

Новые изменения в файле, сделанные после `git add ` - не проиндексированы, следовательно сохранены не будут. Чтобы 
избежать потери последних изменений нужно ещё раз проиндексировать этот файл с помощью `git add`.  
Обычно, индексация и сохранение изменений производятся последовательно сразу, чтобы избежать потерь.

Ошибочно проиндексированный файл можно убрать из набора, подготовленного для сохранения, командой 

    git rm --cached %имя_файла%
    
Добавление новых файлов, переименование, перемещение файлов, удаление файлов, изменение содержимого файлов - все эти 
операции *являются изменением*. Соответственно, если пользователь желает зафиксировать эти изменения, все такие файлы 
должны быть явно проиндексированы. В том числе удалённые(перемещённые) - для текущего сохранённого состояния они ещё 
существуют, git о них "помнит".

В *IntelliJ IDEA* все изменения в имеющихся неигнорируемых файлах индексируются автоматически. Включая перемещение, 
переименование, удаление файлов.  
Новые неигнорируемые файлы - в зависимости от настроек *IDEA* - либо тоже автоматически индексируются, либо *IDEA* 
запрашивает решение у пользователя при создании файла в отслеживаемой директории.    
Если файл не проиндексирован, но его нужно добавить, сделать это можно рядом способов:  
(Необходимо, чтобы в дереве проекта был выбран нужный файл, либо открыт редактор нужного файла)
- верхнее меню => `VCS` => `Git` => `Add`;
- в дереве проекта `RMB` на нужном файле => `Git` => `Add`;
- в редакторе файла `RMB` => `Git` => `Add`;
- в диалоговом окне VCS (<code>Alt + \`</code>) => `Add to VCS`;
- горячие клавиши `Ctrl + Alt + A` (настраиваемы).

### Фиксация изменений

**Фиксация изменений** - это фактическое сохранение текущего состояния проекта. При фиксации изменений **учитываются 
только проиндексированные изменения**. Таким образом пользователь может гибко определять, какие из произведённых 
изменений нужно зафиксировать.

Команда на фиксацию (сохранение) изменений:

    git commit
    
Настоятельно рекомендуется снабжать фиксацию изменений комментарием с кратким текстовым описанием сохраняемых изменений 
(что было сделано). Это крайне полезно в дальнейшем: для понимания содержимого сохранения; для навигации по сохранённым 
состояниям, и т.д. Комментарий указывается с помощью ключа `-m`.

    git commit -m "сообщение"
    
В результате операции в файлах локального репозитория git будет **сохранено текущее состояние проекта**: учтены все 
проиндексированные изменения. 
    
**Коммитом** (повсеместно употребляемый жаргонизм) называется как сама процедура *фиксации* изменений (чаще всего 
вместе с предварительной индексацией), так и сохранённое *состояние* проекта: очередной узел в хранимой истории 
изменений проекта.  
(Также часто употребляются производные жаргоризмы: *закоммитить*, *закоммиченный* и т.д.).

Коммиту присваивается уникальный идентификатор - хэш-сумма коммита: 40 шестнадцатеричных цифр. Например 
`a9ca2c9f4e1e0061075aa47cbb97201a43b0f66f`. Этот хеш (хеш-сумма) используется как "имя" (идентификатор) коммита во 
многих других командах git: при навигации по коммитам, слиянии коммитов от нескольких авторов, и т.д.  

Уникальность хеш-суммы не 100%-ная, но 16^40 вариантов - это настолько большое число, что вероятность совпадения хешей 
двух коммитов ничтожна.   
Более того, на практике для идентификации коммита зачастую используются только первые несколько (например, 8, 10 или 
16\) "цифр" хеша - git это позволяет, - и они почти наверняка будут уникальны для всех коммитов даже очень больших 
проектов. 

Удобная сокращённая команда 
    
    git commit -a "сообщение коммита"
    
заменяет собой две:

    git add *
    git commit -m "сообщение коммита"
    
т.е. проиндексировать все изменённые неигнорируемые файлы и сделать коммит с комментарием.  
Кстати, git позволяет использование нескольких команд подряд (в одной строке): их нужно просто указать через запятую.

В *IntelliJIDEA* есть несколько путей сделать коммит:
- коммит *одного* файла:
    - в дереве проекта `RMB` на файле => `Git` => `Commit File ...`;
    - в открытом редакторе файла `RMB` => `Git` => `Commit File ...`;
    - (при фокусе на файле в дереве проекта / либо при открытом редакторе файла) в верхнем меню:
        `VCS` => `Git` => `Commit File...`;
    - (при фокусе на файле в дереве проекта / либо при открытом редакторе файла) вызвать диалоговое окно VCS 
        (<code>Alt + \`</code>) => `2. Commit File...`;
- коммит *нескольких* (в т.ч. и одного) файлов:
    - в верхнем меню: `VCS` => `Commit`;
    - в диалоговом окне VCS (<code>Alt + \`</code>) => `1. Commit...`;
    - горячими клавиами `Ctrl + K` (настраиваемые).

Во всех случаях будет открыто диалоговое окно коммита (с выбранным одним конкретным файлом, или всеми изменёнными 
неигнорируемыми файлами, соответственно), где пользователь может "галочками" выбрать какие конкретно файлы нужно 
сохранить; задать комментарий к коммиту; просмотреть сводку изменений в файлах; и подтвердить действие кнопкой `Commit` 
(или `Commit and Push` (см. ниже)).  
*IDEA* автоматически индексирует изменения для выбранных файлов, т.е. по факту `git add` и `git commit` всегда 
происходят вместе, нет необходимости отслеживать это дополнительно.

### Просмотр истории коммитов

Команда 

    git log
    
Покажет историческую сводку по всем сделанным коммитам в текущей *ветке* (см. ниже) репозитория от самого позднего 
(текущего) коммита до самого раннего (изначального) коммита. В записях истории указывается хеш коммита, автор, дата и 
комментарий.

История выводится постранично, навигация осуществляется управляющими клавишами, выход: `q`

В *IntelliJIDEA* история коммитов отображается в нижнем меню: `9: Version Control` (`Alt + 9`) => `Log`.  
Доступна фильтрация по свойствам коммита; поиск по хешу, по комментарию.    
По каждому из коммитов можно получить сводку изменённых файлов, в каждом из них получить изменения по сравнению с 
предыдущим или с текущим состоянием и прочее.
Здесь же осуществляется навигация по коммитам (см. ниже) с помощью контекстного меню (`RMB` по коммиту).

### Связь локального репозитория с удалённым

До сих пор речь шла про локальное сохранение изменений, сделанное одним пользователем. Перейдём к работе с удалённым 
репозиторием.  
Удалённый репозиторий используется для:
- резервного копирования данных;
- распространения исходного кода другим пользователям;
- хранения главной (общей, стабильной) версии кода (в то время как в локальном репозитории ведётся работа над текущими 
    задачами);
- синхронизации локальных репозиториев различных пользователей;
- объединения изменений, сделанных различными пользователями.

Фактически, удалённый репозиторий - это ещё один такой же git-репозиторий, действующий по тем же правилам: так же 
хранит состояния проекта (коммиты), так же обновляется через коммиты, и т.д.

Для дальнейшей работы удалённый репозиторий должен существовать. На GitHub его можно создать в web-интерфейсе 
пользователя.

Для связи локального репозитория с удалённым необходимо в рабочей директории проекта (локально) выполнить команду:

    git remote add %name% %URL%

Эта команда указывает локальному репозиторию направление на привязанный к нему удалённый репозиторий.   
Здесь `%name%` - это *имя*, которое локальный репозиторий присваивает привязанному удалённому репозиторию. В дальнейшем 
удалённый репозиторий будет идентифицироваться этим именем. Имя может быть любым (допускается латиница, должно быть 
уникально для данного репозитория), но принято главный удалённый репозиторий называть `origin`.  
Далее, `%URL%` здесь это сетевая ссылка (URL) до нужного удалённого репозитория, например 
`https://github.com/SlepuhinAlexander/tst-git.git`.

У одного удалённого репозитория может быть множество привязанных к нему локальных репозиториев (например, на 
компьютерах всех участников проекта): чтобы привязать второй локальный репозиторий к этому же удалённому, необходимо в 
месте расположения второго локального репозитория выполнить эту же команду с той же ссылкой и именем.

У одного локального репозитория может быть привязано множество удалённых репозиториев (например, для резервного 
копирования). Для привязывания второго удалённого репозитория нужно выполнить эту же команду, но уже с новым именем и 
соответствующей ссылкой. 

Связь локального репозитория с удалённым - однократная процедура. В дальнейшем производится синхронизация локального 
репозитория с удалённым: отправка локальных изменений (`push`); обновление локальной версии до общей (`pull`).  

Удалить связь локального репозитория с удалённым (если она больше не нужна) можно командой

    git remote remove %имя%

где в качестве `%имя%` указать имя удалённого репозитория заданное при связке. Например: `git remote remove origin`

В *IntelliJIDEA* добавление / удаление / редактирование связей с удалёнными репозиториями расположено в диалоговом окне 
`Git Remotes`, которое можно открыть из верхнего меню: `VCS` => `Git` => `Remotes`.

### Отправка изменений в удалённый репозиторий

Действие по отправке изменений в удалённый репозиторий называется `push` (от названия команды `git push`; так же 
встречаются жаргоризм "пуш" и его производные: "запушить", "запушенный" и т.д.).

Единицей изменений при передаче между репозиториями является коммит. Т.е. для того чтобы отправить изменения файлов в 
удалённый репозиторий их нужно сперва закоммитить в локальный.

При пуше в удалённый репозиторий будут отправлены все (ранее не запушенные) коммиты текущей ветки, одним действием.

Общий вид команды

    git push %имя_репозитория% %имя_ветки%

где в качестве `%имени_репозитория%` нужно указать имя привязанного удалённого репозитория; а `%имени_ветки%` - имя 
целевой ветки (см. ниже) в этом удалённом репозитории.
     
например

    git push origin master
    
здесь `origin` - имя основного удалённого репозитория; `master` - имя основной ветки в целевом репозитории (ветка 
`master` в любом репозитории создаётся по умолчанию).

При этом может потребоваться ввод логина-пароля от удалённого репозитория (от учётной записи на GitHub в данном 
случае).

Краткая форма записи

    git push
    
использует текущие сохранённые значения для `%имени_репозитория%` и `%имени_ветки%` (если они есть).  
Установить / обновить эти сохранёные значения (вместе с пушем) можно при помощи ключа `-u`, например:

    git push -u origin master
    
В *IntelliJIDEA* отправку изменений (`push`) можно сделать:
- сразу вместе с коммитом (см. выше);
- в верхнем меню: `VCS` => `Git` => `Push...`
- в диалоговом окне VCS (<code>Alt + \`</code>) => `8. Push...`;
- горячими клавишами `Ctrl + Shift + K` (настраиваемые).

Будет открыто диалоговое окно `Push Commits` со сводкой по коммитам, готовым к отправке. В каджом из коммитов можно 
посмотреть список файлов, автора, дату, комментарий, и т.д. Подтверить действие нужно кнопкой `Push`.

В результате пуша в удалённом репозитории будет сделан коммит, объединяющий все отправленные изменения.

### Выкладка проекта в удалённый репозиторий

В *IntelliJIDEA* есть удобная интеграция с GitHub, с её помощью можно практически в одно действие проект, находящийся 
под контролем git локально, выложить целиком на GitHub (минуя этапы создания удалённого репозитория, связывания с ним 
локального и т.д.).

В верхнем меню: `VCS` => `Import Into Version Control` => `Share Project on GitHub`. В открывшемся диалоговом окне 
нужно ввести логин-пароль от аккаунта на GitHub, а далее указать имя удалённого репозитория (по умолчанию origin), 
название репозитория на GitHub и, опционально, описание.

В результате будет создан выбранный удалённый репозиторий на GitHub, он же будет связан с текущим локальным 
репозиторием и *IDEA* выполнит `git push` всех коммитов текущей ветки.

Таким образом, на GitHub появится полная копия выложенного проекта (за исключением файлов, указанных в `.gitignore`).

### Синхронизация локального репозитория с удалённым

Обратная операция к `git push`  - это получение текущего состояния удалённого репозитория и применение его к 
локальному. Состояние удалённого репозитория могло измениться, если туда был сделан пуш из другого репозитория (от 
другого пользователя).  
Операция называется `push` (от названия команды `git pull`; так же встречаются жаргоризм "пул(л)" и его производные: 
"запул(л)ить", "запул(л)еный" и т.д.).

Синтаксис команды:

    git pull %имя_репозитория% %имя_ветки%
    
где в качестве `%имени_репозитория%` указываетя имя удалённого репозитория (обычно - `origin`), а в качестве 
`%имени_ветки%` - имя интересующей ветки в нём (часто - `master`).

Краткая запись `git pull` использует репозиторий `origin` и ветку `master`.

В *IntelliJIDEA* синхронизацию (`pull`) можно сделать:
- в верхнем меню: `VCS` => `Git` => `pull` (с выбором репозитория / ветки для обновления);
- в верхнем меню: `VCS` => `Update Project...` (со значениями репозитория / ветки по умолчанию);
- горячими клавишами `Ctrl + T` (настраиваемые). 

В результате git синхронизует состояние локального репозитория с указанным удалённым репозиторием: фактически 
производится коммит в локальный репозиторий всех подтянутых коммитов из удалённой ветки в локальную версию этой ветки, 
а затем, если текущая ветка отличается от запрошенной, - их `merge` (см. ниже) в текущую локальную ветку.

### Клонирование репозитория

Для копирования проекта целиком из удалённого репозитория (локально проекта ещё нет) используется команда 

    git clone %URL%
    
Выполнять команду необходимо в директории будущего склонированного проекта. А в качестве `%URL%` указать сетевую ссылку 
(URL) клонируемого репозитория, например `https://github.com/jjd-ifmo/lessons.git`

В результате будет создан локальный git-репозиторий, наполненный скопированными данными. Полученный проект можно 
затем скопмилировать и запустить.

В *IntelliJIDEA* создать новый проект путём клонирования из удалённого репозитория можно:
- В верхнем меню: `File` => `New` => `Project From Version Control`;
- В верхнем меню: `VCS` => `Git` => `Clone...`.

В обоих случаях откроется диалоговое окно клонирования проекта из системы контроля версий, где нужно указать `URL` 
репозитория (либо выбрать существующий репозиторий на GitHub) и указать путь до директории создаваемого проекта.  
Далее нужно пройти через стандартные этапы создания проекта в *IDEA*.

После завершения кланирования проект, возможно, необходимо будет настроить (некоторые настройки могут произойти 
автоматически):
- выбрать директорию с исходным кодом: в дереве проекта `RMB` по директории с исходным кодом (обычно `src`) => `Mark 
    Directory as` => `Sources Root` (директория должна подсветиться голубым цветом).
- далее в настройках проекта `File` => `Project Structure` => вкладка `Project` (или горячие клавиши 
`Ctrl + Alt + Shift + S): 
    - выбрать Project SDK (JDK): выбрать небходимую версию платформы Java из установленных на компьютере.  
        Она не должна быть ниже, чем версия языка, на котором написан склонированный проект, иначе нет гарантии его 
        работоспособности.
    - выбрать Project language level - уровень языка для *IDEA*. Используется в проверках, подсветках, подсказках 
        производимых *IDEA* в помощь пользователю.  
        Он не должен быть выше версии JDK
    - выбрать Project compiler output - директорию для скомпилированных класс-файлов. Обычно `./out/`  

# TODO: конфликты, их разрешение, ветвления, работа с ветками, навигация по коммитам / веткам, стеш.

-----------------------------------------------------------------------------------


конфликты и их разрешения.

когда возникают конфликты:
в момент pull
в момент слияния веток
в момент, когда локальные изменения ещё не сохранены (не закоммичены)

Например, с момента, когда было получено последнее состояние на локальный репозиторий, состояние на удалённом репозитории изменено, и на локальном в тех же строках изменено иначе.
при попытке git pull в локальный репозиторий у git возникнет конфликт: не понятно какое из двух изменённых состояний необходимо применить.
т.е. git pull не произойдёт. никакие изменения не подтянутся

далее, если локальные изменения всё же нужно сохранить:
 - git add
 - git commit
(локальные изменения локально сохранены)
 - при попытке git push будет конфликт: слияние невозможно
в результате в файле будут записаны оба варианта изменений и нужно будет вручную разрешить конфликт

имеет такой вид
    <<<<<<< HEAD
    New message
    =======
    Some conflicted text
    >>>>>>> 38508657ad15813900300a8896a51cfa1631be16
здесь HEAD указание на текущий коммит

необходимо установить конечное содержимое файла с учётом того что вы хотите сохранить
затем git add, git commit
и git pull чтобы убедиться что конфликтов больше нет


вариант, когда локальные изменения ещё не сохранены (не закоммичены) и мы хотим их "спрятать"
команда git stash
она возвращает проект к состоянию последнего коммита

(stash-ей может быть сколько угодно)

варианты как поступить со stash:
 - спрятать и не открывать. git pull при этом выполнится без каких-либо проблем
 - вернуть
 
команда на возврашение отложенного в stash:
git stash apply
при этом может быть конфликт: если файл уже был изменён с момента откладывания в stash

===========================
------

команда на сброс
git reset --hard HEAD
отменяет все изменения, возвращает в состояние переданного коммита
здесь HEAD - указатель на последний коммит
вместо него может быть hash-сумма конкретного интересующего коммита


-----

git revert <коммит>
создаёт новый коммит поверх предыдущего, в котором отменяет все изменения, которые были сохранены в <commit>

------



команды перемещения по коммитам:
1. команда для просмотра коммита:
git checkout <коммит>
git checkout <имя ветки> -- вернуться назад
не применим, если есть незакоммиченные изменения. их можно положить в stash

2. возвращение к какому-то коммиту и продолжение работы из этого состояния.
фактически при этом будет создана новая ветка. в которую будут будут дальнейшие коммиты писаться.
git checkout -b <имя_новой_ветки> <коммит>
команда создаёт новую ветку с указанным именем; работа переключается на эту ветку. и ветка начинается с указанного коммита

git checkout <имя ветки> -- просто переключение на эту ветку.

----------------------------------------------------------

Ветки: 

git branch
показывает список всех имеющихся веток
текущая активная подсвечена залёным

git branch <имя_ветки>
создание новой ветки

git checkout <имя_ветки>
переключение на указанную ветку.

git push <имя_репозитория> <имя_ветки>
отправить на удалённый репозиторий указанную ветку со всеми изменениями в ней

git push <имя_репозитория> --delete <имя_ветки>
удалить ветку из удалённого репозитория

git branch -d <имя ветки>
удаление ветки из локального репозитория

слияние веток:
процедура объединения двух параллельных веток для того чтобы объединить 
git merge <имя_другой_ветки>
производит слияние текущей ветки с другой_веткой
результат будет в текущей ветке