## Карты (Maps)

Мапы - это тоже структура данных как и коллекции, но в отличие от коллекций, где хранятся отдельные элементы, в мапах 
данные хранятся в виде пары **ключ**-**значение**.

Добавление записи в мапу всегда представляет собой добавление элемента, состоящего из ключа и значения.  
Во всех мапах ключи всегда должны быть **уникальными**.   
Каждому ключу должно соответствовать **только одно** значение.
Значения при этом *могут* повторяться.

`Map` не расширяет интерфейс `Collection`
Остальные особенности зависят от конкретной реализации `Map`

Все карты, которые мы сегодня рассмотрим - непотокобезопасны, их нужно использовать в однопоточных средах.

### HashTable 

Медленная карта, ориентированная на многопоточную среду, но и там редко используется.

### HashMap

Наиболее часто употребимая и простая реализация карты.

Особенности HashMap

- хранит ключи в хеш-таблице. Для того чтобы положить элемент в HashMap - вычисляет hashCode ключа.
- для объектов, которые используются в качестве ключей ОБЯЗАТЕЛЬНО должны быть переопределены методы
    equals() и hashCode().
- порядок хранения элементов может отличаться от порядка добавления.
- null можно использовать в качестве ключа. Пара с ключом null будет первой в мапе.

Удобно использовать в качестве ключей тип String. Хэш коды при добавлении объекта постоянно пересчитываются.
А поскольку строки неизменны, но их хэш уже высчитан, хранится в пуле строк и не меняется.

[MapsDemo](MapsDemo.java)
`hashMapDemo()`

Создаём объект `HashMap`

Когда мы создаём пустой объект HashMap.
Внутри у map есть множество различных свойств, происходит инициализация этих свойств.
Внутри объекта HashMap создаётся **массив** `Entry/Node[] table = new Entry|Node[16]`.
`Entry` или `Node` - зависит от версии Java. Ничем не отличаются кроме названия.
Массив заполняется `null`-ами.

    class Entry/Node<K, V> {
        int hashCode;
        K key;
        V value;
        Entry/Node next;
        /* прочий код */
    }

Узел карты хранит `hasCode` хранимого объекта (хэшкод ключа); ключ; значение; и ссылку на следующий элемент.

Этот массив `table` - это и есть хэш-таблица для хранения карты.

Добавляем в карту пару `("Москва", 34)`
1. Проверка существования ключа `"Москва"`
    - если ключ уже существует, то метод останавливается: ничего не происходит, перезаписи не будет, эксепшена не будет.
2. Оптимизация хешкода: на основе hashCode ключа вычисляется hashCode для хранения в таблице. 
3. На основе высчитанного (оптимизированного) хэшкода определяется место элемента в массиве (индекс)
4. Создаётся объект `Entry/Node`, где записывается: 
    - в `hashCode` - оптимизированный хэшкод;
    - в `key` - ключ `"Москва"`;
    - в `value` - значение `34`.
5. Помещение объекта `Entry/Node` в массив:
    - если в массиве на этом индексе пусто - объект помещается в массив и на этом всё.
    - если в массиве на этом индексе занято - объект помещается в конец связного списка в свойство `next`.

Изначальный размер массива `table` можно задать при создании объекта `HashMap`.
`HashMap` умеет автоматически расширять размер массива `table` при необходимости (при достижении порогового значения 
средней длины связного списка).

### Перебор коллекции

[MapsDemo](MapsDemo.java)
`mapIterationDemo()`

### EnumMap

Особенности `EnumMap`
- в качестве ключей использует enum: все ключи должны быть одного типа, т.е. принадлежать одному enum 
- не использует хэшкоды ключей
- нельзя использовать null в качестве ключа
- порядок хранения элементов соответствует порядку элементов enum
- значения хранит в массиве (размер массива - количество елементов enum)  
    размер массива определяется один раз  
    размер массива не меняется  
    изначальный размер массива - количество элементов enum  
- для извлечения из массива использует порядковый номер ключа

[MapsDemo](MapsDemo.java)
`enumMapDemo()`

### TreeMap

Особенности TreeMap:
- хранит элементы в отсортированном по ключам виде
- основан на алгоритме красно-чёрного дерева
- нельзя использовать null в качестве ключа
- класс, объекты которого являются ключами должен быть сортируемым:
    - либо сам класс должен реализовывать интерфейс Comparable;
    - либо TreeMap в конструктор нужно передать Comparator, сравнивающий объекты ключей.  

Речь идёт именно о ключах. Значения не сортированы, они жёстко привязаны к ключам.

[MapsDemo](MapsDemo.java)
`treeMapDemo()`

Алгоритим чёрно-красного дерева:  
Первый элемент добавляется в корень дерева
Если новый приходящий элемент меньше корня - он добавляется в левое дерево; если больше - в правое дерево.
В каждом из поддеревьев повторяется алгоритм:
    если узла нет - он добавляется и конец алгоритма
    если узел есть - определяется в левое или в правое дерево добавить.
    
Красно-чёрное дерево:
Тоже бинарное дерево, но плюс дополнительные правила:
1. каждый узел либо красный либо чёрный
1. корень - чёрный
1. нулевые указатели считаются листьями, причём листья - чёрные.
1. потомки красного узла - всегда чёрные (потомки чёрного узла - не обязательно красные)
1. любой путь от корня поддерева до листа содержит одинаковое число чёрных узлов (глубина по чёрным узлам)

Грубая оценка на основании правил 4 и 5 показывает, что длины двух соседних поддеревьев отличаются не более чем в 2 
раза.
Каждый новый узел изначально считается красным. Если это нарушает одно из правил, обычно 4 или 5, производится 
балансировка.

### WeekHashMap

Особенности WeakHashMap
- Хранит ключи в хэш-таблице
    соответственно в классе ключей должны быть переопределены `equals()` и `hashCode()`
- можно использовать `null` в качестве ключа
- запись в `WeakHashMap` **будет удалена** при сборке мусора, если на ключ не осталось сильных ссылок.