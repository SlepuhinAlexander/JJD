## Строки

**Строки** - это тип данных, предназначенный для хранения строки текста. В Java строки имеют тип данных `String` 
(`java.lang.String`).

`String` является *ссылочным* типом данных, а каждая строка является **[объектом](../l06oop/ClassesAndObjects.md)**.

### Хранение строк

До версии Java 8 (включительно) строки хранятся как массив символов (примитивов) - `char[]`, т.е. каждый отдельный 
[`char`](../l01basesyntax/DataTypes.md#char)

    char someChar = `e`;

хранит один в себе один символ, а [массив](../l03arrays/Arrays.md) `char[]`

    char[] charts = {'J', 'J', 'D'};

хранит в себе упорядоченный набор символов.  

Если посмотреть реализацию самого [класса](../l06oop/ClassesAndObjects.md) `String` можно увидеть, что он хранит 
свойство

    private final char[] value;
   
Это и есть значение хранимой строки - массив символов.  
При этом каждый `char` занимает 2 байта и для хранения символов используется кодировка 
[UTF-16](https://ru.wikipedia.org/wiki/UTF-16)

Начиная с версии Java 9, когда была введена функциональность "компактные строки", строки хранятся как массив `byte[]`.

    private final byte[] value;
    
При этом вместе с массивом `value` хранится информация о том, какую кодировку использует строка

    private final byte coder;

с возможными значениями `LATIN1` и `UTF16`.

В компактных строках в случаях, если символ помещается в 1 байт - используется кодировка 
[LATIN-1](https://ru.wikipedia.org/wiki/ISO_8859-1) (которая занимает как раз 1 байт); иначе - используется кодировка 
[UTF-16](https://ru.wikipedia.org/wiki/UTF-16) и символ занимает уже 2 байта (2 смежных элемента массива байт).

### Создание строк

Для объявления переменной типа строка, так же как и для 
[объявления любой переменной](../l01basesyntax/DataTypes.md#using-variables) необходимо указать тип данных (`String`) и 
имя переменной

    String someString;

Для создания объекта строки необходимо либо присвоить строковой переменной текстовую строку, либо использовать один из 
[конструкторов](../l06oop/ClassesAndObjects.md) класса `String`.

Текстовая строка представляет собой последовательность символов, заключённых в *двойные* кавычки, например `"JJD"`.  
Такая текстовая строка, заданная явным образом называется **строковым** (или **текстовым**) **литералом** - по аналогии 
с численными литералами, используемыми для [примитивных типов](../l01basesyntax/DataTypes.md#primitives).

    String someString1 = "JJD";
    
Объявлена переменная `someString1` с типом `String` и ей присвоено значение `"JJD"`.  
В результате в созданной строке хранится последовательность байт (или символов - в зависимости от версии Java): 
`'J'`, `'J'`, `'D'`.

Поскольку строка - это объект, её, как и любой объект, можно создать с помощью 
[конструктора класса](../l06oop/ClassesAndObjects.md) `String`:

    String someString2 = new String("Some String");

Объявлена переменная `someString` с типом `String` и ей присвоен результат работы конструктора `String()` с аргументом 
`"Some String"`.  
В результате в созданной строке хранится последовательность байт (или символов - в зависимости от версии Java): 
`'S'`, `'o'`, `'m'`, `'e'`, `' '`, `'S'`, `'t'`, `'r'`, `'i'`, `'n'`, `'g'`.

Создание строк через строковые литералы - предпочтительно. Конструктор `String()` стоит использовать только если без 
него не обойтись: например при создании строк из массива или потока байт, или иными нетипичными способами. 

#### Пул строк

Строки в Java **неизменяемы** и **потокобезопасны**.   
Неизменяемость означает, что однажды созданный объект строки в дальнейшем не может быть изменён, можно только создать 
новую строку на основе старой.  
Потокобезопасность означает корректную работу со строками в многопоточных приложениях: все потоки будут работать с 
одними и теми же значениями строк. 

В процессе работы программы [JVM](../l01basesyntax/Introduction.md#jvm) выделяет в 
[модели памяти](../l13enumsgc/Notes.md) особый раздел String Pool (пул строк), отведённый для хранения объектов строк.

Объявление строкового литерала - это уже создание объекта строки.  
Каждый раз, когда создаётся или вычисляется (см. методы строк) новый строковый литерал, JVM проверяет, нет ли уже такой 
строки в пуле строк:
- если такая строка не найдена, JVM создаёт новый объект строки, помещает его в пул строк, и возвращает ссылку на него 
    вызывающему коду.
- если такая строка в пуле строк есть, новая строка **не создаётся**, вместо этого JVM возвращает вызывающему коду 
    ссылку на уже имеющуюся строку в пуле строк.
    
При изменении строк (см. методы строк) строка на самом деле не изменяется, а на её основе создаётся новая строка в пуле 
строк и JVM возвращает вызывающему коду ссылку на новую созданную строку. Исходная строка в пуле строк при этом 
остаётся неизменна (и может быть использована позже, когда программе потребуется именно эта строка).

Все строки, объявленные как строковые литералы, или созданные на их основе - хранятся в пуле строк и используют его.

Плюсы от использования пула строк:
- быстродействие - обращаться к существующим объектам быстрее, чем создавать новые.
- экономия памяти - не создаются массово новые объекты, для одних и тех же строк.
- все строковые литералы в константных выражениях заранее вычисляются на этапе компиляции и затем результат каждого из 
   этих выражений используется как литерал.
- неизменяемость строк:
    - ещё раз быстродействие - нет необходимости пересоздавать массив, хранящий значение строки, что было бы затратной 
        операцией.
    - даёт возможность [методу](../l06oop/ClassesAndObjects.md) работать с аргументом-строкой как с примитивом - если 
        метод в процессе своей работы "изменит" пришедший аргументом параметр-строку на исходную строку, переданную 
        аргументом в метод это никак не повлияет.
    - потокобезопасность - все потоки приложения гарантированно будут работать с одним и тем же значением строки.
    
Минусы от использования пула строк:
    - накладные расходы на поиск совпадения в пуле.
    - не все строки хранятся в пуле строк.

Все строки, *созданные с помощью конструктора* класса `String`, всегда создаются как *отдельный объект*, в пуле строк 
*не участвуют*, и поэтому как объекты всегда различны. Кроме того, такие строки создаются уже на этапе выполнения, как 
и любые другие [объекты](../l06oop/ClassesAndObjects.md). 

#### Равенство строк

Для строк, как и для любых объектов, [равенство](../l09objectclass/ObjectClass.md#equals) можно понимать двояко:
- равенство **ссылок** на объекты: если две ссылки равны, то они обе ссылаются на один и тот же объект. То есть 
    сравниваемые объекты равны как объекты (являются одной и той же сущностью, одной и той же областью в памяти).
- равенство **значений** объектов: если значения объектов равны, то оба объекта **равнозначны**, при этом они могут 
    являться разными объектами, а могут быть и одним и тем же.

Из равенства объектов всегда следует их равнозначность, поскольку это фактически один и тот же объект. Обратное не 
верно: два разных объекта могут хранить одинаковые значения.

Что понимается под *значением* и *равенством значений* - зависит от реализации класса (реализации его метода 
`equals()`) и, вообще говоря, может быть чем угодно. Конкретно для класса `String` равнозначными строками считаются две 
строки, хранящие одну и ту же последовательность символов.

Для сравнения ссылок двух объектов (в частности, строк) используется оператор `==` (или противоположный ему `!=`).  
Для сравнения значений двух объектов (в частности, строк) используется метод `equals()` этого объекта. Метод 
`String.equals()` проверяет, хранят ли обе строки одну и ту же последовательность символов.

[StringsDemo.java][Strings]
    
    stringEqualityDemo() {
        /* <code> */
        // Сравнение строк:
        String string1 = "Some String";
        String string2 = "Some String";
        String string3 = new String("Some String");
        String string4 = new String("Some String");
        // сравнение ссылок на строки
        System.out.println("string1 == string2 : " + (string1 == string2)); // string1 == string2 : true
        System.out.println("string1 == string3 : " + (string1 == string3)); // string1 == string3 : false
        System.out.println("string3 == string4 : " + (string3 == string4)); // string3 == string4 : false
        // сравнение значений строк (посимвольное сравнение)
        System.out.println("string1.equals(string2) : " + string1.equals(string2)); // string1.equals(string2) : true
        System.out.println("string1.equals(string3) : " + string1.equals(string3)); // string1.equals(string3) : true
        System.out.println("string3.equals(string4) : " + string3.equals(string4)); // string3.equals(string4) : true
        /* <code> */
    }

Из результатов примера видно, что строки `string1` и `string2`, созданные из литералов и хранящиеся в пуле строк, 
фактически являются одним и тем же объектом: их ссылки равны.  
А строки `string3` и `string4`, созданные через конструктор `String()` являются разными объектами: их ссылки не равны.  
Но при этом все четыре строки хранят одинаковые значения.

Для строк *сравнение через ссылки не имеет практического смысла*. Сравнивать строки всегда следует **по значению**: с 
использованием метода `equals()`.

#### Помещение строки в пул строк

Строку можно принудительно поместить в пул строк. Для этой цели служит метод `intern()` класса `String`.  
Метод `intern()` ищет в пуле строк строку, равную (через `equals()`) вызывающему объекту, далее:
- если строка найдена в пуле строк, метод просто возвращает ссылку на эту строку в пуле строк;
- если строка не найдена в пуле строк, метод помещает вызывающую строку в пул и возвращает ссылку на эту строку в пуле 
строк. 

[StringsDemo.java][Strings]
    
    stringEqualityDemo() {
        /* <code> */
        String string3 = new String("Some String");
        String string4 = new String("Some String");
        System.out.println("string3 == string4 : " + (string3 == string4)); // string3 == string4 : false
        System.out.println("string3.intern() == string4.intern() : " + (string3.intern() == string4.intern())); 
        // string3.intern() == string4.intern() : true
        System.out.println("string3 == string4 : " + (string3 == string4)); // string3 == string4 : false
        string3 = string3.intern();
        string4 = string4.intern();
        System.out.println("string3 == string4 : " + (string3 == string4)); // string3 == string4 : true
        /* <code> */
    }

Метод `intern()` возвращает ссылку на строку в пуле строк, исходный объект строки при этом не изменяется.  
Чтобы использовать результат помещения строки в пул, нужно ссылку, возвращаемую методом `intern()` сохранить в 
переменную или передать в выражение / метод.

 
### Методы строк

Поскольку в основе хранения строки лежит массив её символов (или байт), строке так же как и массиву присуще понятие 
*индекса*. **Индексом** *символа* в строке называется его номер (позиция) в строке. Как и у массивов, нумерация 
индексов символов начинается **с нуля**.

Многие методы класса `String` принимают в качестве аргумента индекс или возвращают индекс. Например, с какой позиции в 
строке начинать выполнять действие; или на какой позиции находится символ, удовлетворяющий условию.  
Некоторые методы принимают в качестве аргумента диапазон индексов, т.е. два индекса: начальный и конечный. Как и для 
массивов, во всех таких методах начальный индекс включается, конечный - не включается. 
  
Так же как и у массивов, обращение к несуществуюшему индексу (выходящему за пределы строки) приведёт к выбросу ошибки 
`java.lang.IndexOutOfBoundsException`. Использование конечного индекса меньшего, чем начального, приведёт к этой же 
ошибке.

Все методы строк вызываются от уже созданного [объекта](../l06oop/ClassesAndObjects.md) строки. Если переменная строки 
пуста (равна `null`), т.е. на самом деле не хранит объект строки, то вызов методов от неё приведёт к выбросу ошибки 
`java.lang.NullPointerException`.

#### Общие методы

Метод `length()` возвращает количество символов (длину) вызывающей строки. Фактически, это длина массива, хранящего 
строку.

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        String str1 = "Some String";
        System.out.println("str1.length() = " + str1.length()); // str1.length() = 11
        /* <code> */
    }

Метод `isEmpty()` проверяет, является ли вызывающая строка пустой. Возвращает `true` если длина строки равна нулю, и 
`false` в обратном случае

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        String str2 = "";
        System.out.println("str2.isEmpty()? " + str2.isEmpty()); // str2.isEmpty()? true
        /* <code> */
    }

Метод `isBlank()` проверяет, состоит ли вызывающая . Возвращает `true` если длина строка содержит только пробельные 
символы, и `false` в обратном случае.

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        String str1 = "Some String";
        System.out.println("str3.isBlank()? " + str3.isBlank()); // str3.isBlank()? true
        /* <code> */
    }

Метод `toUpperCase()` преобразует вызывающую строку к верхнему регистру и возвращает результирующую строку.

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        String str1 = "Some String";
        System.out.println("str1.toUpperCase() = " + str1.toUpperCase()); // str1.toUpperCase() = SOME STRING
        /* <code> */
    }


Метод `toLowerCase()` преобразует вызывающую строку к нижнему регистру и возвращает результирующую строку.

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        String str1 = "Some String";
        System.out.println("str1.toLowerCase() = " + str1.toLowerCase()); // str1.toLowerCase() = some string
        /* <code> */
    }

Метод `charAt()` возвращает символ (`char`), который вызывающая строка хранит по указанному индексу (на указанной 
позиции).        

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        String str1 = "Some String";
        System.out.println("str1.charAt(1) = " + str1.charAt(1)); // str1.charAt(1) = o
        /* <code> */
    }
    
Метод `valueOf()` - статический метод класса String. Он принадлежит классу `String` в целом, а не какому-либо его 
экземпляру. Метод `valueOf()` необходимо вызывать от класса `String`.  
Метод возвращает строковое представление своего аргумента: это может быть любой тип данных: и примитивный и ссылочный.

[StringsDemo.java][Strings]
    
    stringCommonMethodsDemo() {
        /* <code> */
        System.out.println("String.valueOf(123 + 456) = " + String.valueOf(123 + 456));
        // String.valueOf(123 + 456) = 579
        /* <code> */
    }

#### Форматирование строк

Строки можно чрезвычайно гибко форматировать.
Класс `String` имеет [статический метод](../l08staticfinal) `format()`, который преобразует переданную строку и 
дополнительные аргументы в заданный формат. Например.

    String.format("String with int: %02d, float: %.2f", 1, 1.5);
    
Здесь и строка `"String with int: %02d, float: %.2f"` и полученный результат работы метода - это будет строковый 
литерал, под каждый из них будет создан один объект типа `String` в пуле строк.  
Результатом будет строка `"String with int: 01, float: 1,50"`

Результат работы метода можно присвоить строковой переменной, и использовать позже, например, 
[вывести в консоль](../l01basesyntax/BasicInputOutput.md#output)

    String s1 = String.format("String with int: %02d, float: %.2f", 1, 1.5);
    System.out.println(s1); // String with int: 01, float: 1,50
    
То же самое можно сразу вывести в консоль с помощью статического метода 
[`printf()`](../l01basesyntax/BasicInputOutput.md#formatting):

    System.out.printf("String with int: %02d, float: %.2f", 1, 1.5); // String with int: 01, float: 1,50

На самом деле, оба метода внутри себе вызывают статически метод `format()` класса `java.util.Formatter`, 
специализирующегося на форматировании строк.  
Метод `format()` **очень** гибкий и обладает собственным синтаксисом для шаблонов форматов. Некоторые примеры были 
приведены при знакомстве с методом [`printf()`](../l01basesyntax/BasicInputOutput.md#formatting); полный список 
возможностей доступен в 
[документации](https://docs.oracle.com/en/java/javase/13/docs/api/java.base/java/util/Formatter.html) метода 
`format()`.  

Процедура форматирования довольно трудоёмка, это стоит учитывать при проектировании приложения.

#### Преобразование строки в массив и обратно

Строку можно преобразовать в массив символов или в массив байт, используя, соответственно, методы `toCharArray()` и 
`getBytes()`







    // общие
    toCharArray()
    getBytes()

    // сравнение
	equals​(Object anObject)
	equalsIgnoreCase​(String anotherString)
	startsWith​(String prefix)
	startsWith​(String prefix, int toffset)
    endsWith​(String suffix)
    compareTo​(String anotherString)
    compareToIgnoreCase​(String str)

    // объединение и разбиение
    concat​(String str)
	join​(CharSequence delimiter, CharSequence... elements)
	repeat​(int count)
	split​(String regex)
	substring​(int beginIndex)
    substring​(int beginIndex, int endIndex)

    
    // поиск и замена
    contains​(CharSequence s)
	indexOf​(int ch)
	indexOf​(int ch, int fromIndex)
    indexOf​(String str)
    indexOf​(String str, int fromIndex)
	lastIndexOf​(int ch)
	lastIndexOf​(int ch, int fromIndex)
	lastIndexOf​(String str)
	lastIndexOf​(String str, int fromIndex)
	matches​(String regex)
	regionMatches​(boolean ignoreCase, int toffset, String other, int ooffset, int len)
	regionMatches​(int toffset, String other, int ooffset, int len)
	replace​(char oldChar, char newChar)
	replace​(CharSequence target, CharSequence replacement)
    replaceAll​(String regex, String replacement)
	replaceFirst​(String regex, String replacement)





<!--  ------------------------------  -->
[Strings]: StringsDemo.java
