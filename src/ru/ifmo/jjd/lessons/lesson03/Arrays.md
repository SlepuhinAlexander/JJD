## Массивы

### Определения

**Массив** - это объект, представляющий некоторую *непрерывную* область памяти, хранящую *набор* данных (переменных) 
определённого (одного) типа.

Каждая из переменных, хранящихся в массиве называется **элементом** массива.   
Все элементы массива имеют один и тот же тип данных (его иногда называют **типом данных массива**). Массивы можно 
использовать для **любого** типа данных.    
Все элементы массива располагаются в *неизменном порядке*: занимают ячейки памяти *последовательно*, т.к. весь массив - 
непрерывная область памяти. Такое расположение элементов массива в памяти даёт большее быстродействие при работе с 
массивами (в сравнении с работой с отдельными переменными).

Количество элементов в массиве называется **длиной** (или **размером**) массива. Длина массива всегда целое 
неотрицательное число. Массив длиной 0 элементов - допустим, он не содержит никаких данных. Длина массива *задаётся 
при* его *создании*. В дальнейшем длину массива изменить *невозможно*, можно только оперировать с его отдельными 
элементами.

Все элементы массива пронумерованы (проиндексированы) целыми числами. Номер (позиция) элемента в массиве называется 
**индексом** элемента в массиве. Индексация (нумерация) элементов всегда начинается с нуля; индекс указывает на позицию 
конкретного элемента в массиве относительно начала массива.  
Таким образом в массиве из 10 элементов начальный элемент будет иметь индекс (номер) 0, а конечный - 9.  
Индексы используюстя для доступа к конкретному элементу массива.

В платформе Java есть удобный статический класс `Arrays` (`java.util.Arrays`), содержащий методы для выполнения самых 
распространённых действий с массивами. Класс `Arrays` позволяет решать типовые задачи при работе с массивами. 

### Объявление массива

Объявление переменной типа массив, как и для любых других переменных, состоит из указания типа данных и имени 
переменной: 

    int[] someArr;
    
Тип данных указывается как `ТипДанных[]`, где `ТипДанных` - указание типа данных для будущих *элементов* массива, а
`[]` - указание на создание массива. Тип данных можно использовать *любой*.  
Также массив возможно объявить так: `int someArr1[]`. Это работающий, но устаревший способ задания массива, 
унаследованный от языка C. Его использовать не рекомендуется.  

В результате объявления массива будет создана *ссылочная* переменная `someArr` с типом данных `int[]`. Сам массив ещё 
не создан: текущее значение переменной `someArr == null`.  
Массив всегда является *объектом*, в т.ч. если он объединяет данные примитивного типа.

### Инициализация массива

**Инициализация** массива - это момент создания, собственно, массива, заполнения его элементов, и присвоения его 
объявленной переменной массива.
Для создания массива нужно, как минимум, указать его *размер*.  
Размер массива всегда определяется при его создании, и затем не может быть изменён. Наиболее близкая операция к 
изменению размера массива - это создать новый массив нужной длины и скопировать в него даные из старого массива; после 
чего использовать уже новый массив.

Массив, как и объект любого ссылочного типа, создаётся при помощи ключевого слова `new` и указания *конструктора* 
(инициализатора) массива. Простейший конструктор массива - это указание количества элементов в массиве: 

    int[] someArr = new int[7];
    
Здесь объявляется переменная `someArr` с типом массив `int`-ов. Создаётся пустой массив длиной 7 элементов (выделяется 
непрерывная обляасть памяти под хранение семи `int` переменных); каждый элемент масива инициализируется значением по 
умолчанию; созданный массив присваивается переменной `someArr` с тем же типом данных `int[]`.

В качестве аргумента конструктора, указывающего длину массива, можно использовать не только явно число, но и любые 
переменные, выражения, возвращаемые значения методов, которые принимают целочисленные значения (`int`).    
При попытке создать массив отрицательной длины программа выбросит ошибку `java.lang.NegativeArraySizeException` и 
исполнение программы прервётся. Это ошибка времени исполнения (runtime exception), она отлавливается не во время 
компиляции, а уже во время исполнения программы.  
Массив длины 0 создавать можно.

Если элементы массива не инициализированы явно (см. ниже), то при создании массива, его элементы всегда заполняются 
значениями по умолчанию, в зависимости от типа данных элемента:
- целочисленные типы данных заполняются значениями `0`;  
    (в том числе `char`, что равносильно значению `\u0000`);
- дробные числовые типы данных - значениями `0.0`;
- `boolean` - значениями `false`;
- ссылочные типы (строки, массивы, объекты) - значениями `null`.

Элементы массива можно проинициализировать в момент создания массива, для этого в конструктор массива нужно передать 
значения для *всех* его элементов, списком, через запятую, в `{ }`.

    int[] someArr2 = new int[]{37, 48, 125, 983, -23, 0, -112};
  
При этом указывать размер массива уже не нужно: длина массива будет установлена равной количеству переданных 
значений (элементов массива). Количество элементов, переданных в конструктор может быть любым, в том числе нулевым: 
`new int[] {};`

Частично инициализировать массив (т.е. задать только часть значений его элементов, а остальные оставить по умолчанию) - 
невозможно. Для этого нужно создать пустой массив нужной длины и затем, обратившись к нужным его элементам, присвоить 
им нужные значения. 

При явной инициализации массива в момент объявление запись можно сократить: указание `new int[]` - не обязательно. 
Инструкция 

    int[] someArr3 = {37, 48, 125, 983, -23, 0, -112};
    
делает ровно то же самое.

#### Получение длины массива

Длина массива хранится в свойстве `length` объекта типа массив. Получить длину массива можно просто обратившись к этому 
свойству от имени объекта, через точку (см. также [[Объекты]](../lesson06/ClassesAndObjects.md)):

    // ArraysDemo.java
    // arrayInitializationDemo()
    /*
     * <code> 
     */
    int[] someArr = new int[7];
    int[] someArr2 = {37, 48, 125, 983, -23, 0, -112};
    System.out.println("Длина массива someArr: " + someArr.length); // Длина массива someArr: 7
    System.out.println("Длина массива someArr2: " + someArr2.length); // Длина массива someArr2: 7
    
#### Печать массива

Массив является объектом, поэтому вызов печати массива выдаст стандартное текстовое представление объекта (там будет 
напечатан хеш-код объекта), а не содержимое массива, как хотелось бы

    // ArraysDemo.java
    // arrayInitializationDemo()
    /*
     * <code> 
     */
    System.out.println("someArr: " + someArr); // [I@12edcd21
    
Для удобного преобразования массива в строку (например, для вывода в консоль) необходимо использовать служебный 
статический класс `Arrays` (`java.util.Arrays`) и его метод `toString()`, который определён для массивов из всех 
примитивных или ссылочных типов данных.

    // ArraysDemo.java
    // arrayInitializationDemo()
    /*
     * <code> 
     */
    System.out.println("someArr = " + Arrays.toString(someArr)); // someArr = [0, 0, 0, 0, 0, 0, 0]
    System.out.println("someArr2 = " + Arrays.toString(someArr2)); // someArr2 = [37, 48, 125, 983, -23, 0, -112]

#### Повторная инициализация массива

Как и для любой другой переменной - массиву можно присвоить новое значение (переопределить его). При этом массив нужно 
повторно инициализировать (т.е. вызвать конструктор массива того же типа данных и присвоить его имеющейся переменной).  
Можно использовать любой из двух вариантов инициализации. Сокращённую запись явной инициализации использовать уже 
нельзя: инструкцию
    
     someArr = {-4, 12, 37, 48, 125, 983, -23, 0, -112, 33};
     
компилятор уже не распознает.

    // ArraysDemo.java
    // arrayInitializationDemo()
    /*
     * <code> 
     */
    someArr = new int[]{-4, 12, 37, 48, 125};
    someArr2 = new int[5];
    System.out.println("Длина массива someArr: " + someArr.length); // Длина массива someArr: 5
    System.out.println("Длина массива someArr2: " + someArr2.length); // Длина массива someArr2: 5
    System.out.println("someArr = " + Arrays.toString(someArr)); // someArr = [-4, 12, 37, 48, 125]
    System.out.println("someArr2 = " + Arrays.toString(someArr2)); // someArr2 = [0, 0, 0, 0, 0]
    
### Доступ к элементам массива.

После создания массива к любому из его элементов можно обратиться: прочитать его значение или изменить его. Для 
обращения к элементу массива необходимо указать имя массива, и затем в `[]` указать *индекс* интерес интересующего 
элемента.  
В качестве индекса можно передавать не только явное число, но и любую переменную, выражение, возвращаемое значение 
метода, принимающие целое значение (`int`).

    // ArraysDemo.java
    // arrayInitializationDemo()
    /*
     * <code> 
     */
    int[] someArr = new int[7];
    int[] someArr2 = {37, 48, 125, 983, -23, 0, -112};
    System.out.println("someArr[4] = " + someArr[4]); // someArr[4] = 0
    System.out.println("someArr2[7 / 2] = " + someArr2[7 / 2]); // someArr2[7 / 2] = 983
    someArr[1] = 11;
    someArr[5] = 17;
    someArr[someArr2[5]] = 22;
    System.out.println("someArr = " + Arrays.toString(someArr)); // someArr = [22, 11, 0, 0, 0, 17, 0]
    System.out.println("someArr2 = " + Arrays.toString(someArr2)); // someArr2 = [37, 48, 125, 983, -23, 0, -112]

При попытке обращения к несуществующему элементу массива (использовании некорректного индекса), будет выброшена ошибка 
времени исполнения (runtime exception) `java.lang.ArrayIndexOutOfBoundsException` и выполнение программы прервётся.  
Обращение `someArr[i]` вызовет ошибку при `i <= 0 || i >= someArr.length`

### Перебор элементов массива

Задачу перебрать все элементы массива (чтобы прочитать, обработать или изменить значения элементов) удобно решать с 
помощью циклов. Наиболее удобно использовать циклы `for` (т.к. заранее известно необходимое количество итераций, равное 
длине массива) или `foreach` (т.к. массив - итерируемый объект).

Пример:  
Создать массив целых чисел и заполнить его чётными числами начиная с нуля.

    // ArraysDemo.java
    // iteratingTroughArrayDemo()
    /*
     * <code> 
     */
    int[] arr = new int[10];
    for (int i = 0; i < arr.length; i++) {
        arr[i] = i * 2;
    }
    System.out.println("arr = " + Arrays.toString(arr)); // arr = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]
    
Пример:  
Удвоить значения всех элементов массива целых цисел

    // ArraysDemo.java
    // iteratingTroughArrayDemo()
    /*
     * <code> 
     */
    for (int i = 0; i < arr.length; i++) {
        arr[i] *= 2;
    }
    System.out.println("arr = " + Arrays.toString(arr)); // arr = [0, 4, 8, 12, 16, 20, 24, 28, 32, 36]

Та же задача, но с использованием цикла `while`:

    // ArraysDemo.java
    // iteratingTroughArrayDemo()
    /*
     * <code> 
     */
    int i = 0;
    while (i < arr.length) {
        arr[i++] *= 2;
    }
    System.out.println("arr = " + Arrays.toString(arr)); // arr = [0, 8, 16, 24, 32, 40, 48, 56, 64, 72]

Пример:  
Вывести квадраты всех элементов массива. Сам массив не изменять.

    // ArraysDemo.java
    // iteratingTroughArrayDemo()
    /*
     * <code> 
     */
    System.out.print("Квадраты элементов массива arr:");
    for (int n : arr) {
        n = n * n;
        System.out.print(" " + n);
    }
    System.out.println(); // Квадраты элементов массива arr: 0 64 256 576 1024 1600 2304 3136 4096 5184
    System.out.println("arr = " + Arrays.toString(arr)); // arr = [0, 8, 16, 24, 32, 40, 48, 56, 64, 72]
    
Несмотря на изменение переменной `n` внутри цикла, исходный массив не изменился.  
В отличие от перебора циклом `for` (или `while`), цикл `foreach` не использует явно индексы элементов массива: в 
переменную `n` в каждой итерации *копируется* текущий выбранный элемент массива, оригинал при этом остаётся без 
изменений. 
Соответственно, циклом `foreach` пользователь не имеет возможности изменить массив.
