package ru.ifmo.jjd.lessons.l01basesyntax;

public class OperatorsDemo {
    public static void main(String[] args) {
        mathOperatorsDemo();
        comparisonOperatorsDemo();
        assignmentOperatorsDemo();
        logicalOperatorsDemo();
        bitwiseOperatorsDemo();
        ternaryOperatorDemo();
    }

    private static void mathOperatorsDemo() {
        /*
         * Бинарные арифметические операторы (действуют с двумя операндами):
         * + сложение
         * - вычитание
         * * умножение
         * / деление (для целых чисел - деление нацело (остаток отбрасывается))
         * % взятие остатка от деления
         * */
        int a = 17, b = 7;
        System.out.println(a + " + " + b + " = " + (a + b)); // 17 + 7 = 24
        System.out.println(a + " - " + b + " = " + (a - b)); // 17 - 7 = 10
        System.out.println(a + " * " + b + " = " + (a * b)); // 17 * 7 = 119
        System.out.println(a + " / " + b + " = " + (a / b)); // 17 / 7 = 2
        System.out.println(a + " % " + b + " = " + (a % b)); // 17 % 7 = 3
        // чтобы результат операции был числом с плавающей точкой, нужно чтобы
        // либо хотя бы один из операднов был числом с плавающей точкой
        // либо результат операции явно привести к нужному типу. Например:
        System.out.println(a + " / (float)" + b + " = " + (a / (float) b)); // 17 / (float)7 = 2.4285715
        System.out.println("(double)(" + a + " / " + b + ") = " + (double) (a / b)); // (double)(17 / 7) = 2.0
        // во втором случае сначала произведено целочисленное деление, а затем результат приведён к double

        /*
         * Унарные арифметическе операции
         * i++ инкремент (постфиксная форма)
         *     сначала возвращает текущее значение i, а затем присваивает i значение на 1 больше.
         * ++i инкремент (префиксная форма)
         *     сначала присваивает i значение на 1 больше, а затем возвращает обновлённое значение i.
         * i-- декремент (постфиксная форма)
         *     сначала возвращает текущее значение i, а затем присваивает i значение на 1 меньше.
         * --i декремент (префиксная форма)
         *     сначала присваивает i значение на 1 меньше, а затем возвращает обновлённое значение i.
         * */
        a = 2;
        System.out.println("a = " + a);
        System.out.println("-a = " + -a);
        a = -a;
        System.out.println("+a = " + +a);
        System.out.println("-a = " + -a);
        a = -a;
        System.out.println("a++ - ++a + a++ + a++ + a = " + (a++ - ++a + a++ + a++ + a));
        // a++ - ++a + a++ + a++ + a = 13
    }

    private static void assignmentOperatorsDemo() {
        /*
         * Операторы присваивания
         * = присваивание:
         *      a = 12; --- переменной a присвоено значение 12
         * += сложение с присваиванием:
         *      a += b; --- краткая форма записи a = a + b;
         * -= вычитание с присваиванием:
         *      a -= b; --- краткая форма записи a = a - b;
         * *= умножение с присваиванием:
         *      a *= b; --- краткая форма записи a = a * b;
         * /= деление с присваиванием:
         *      a /= b; --- краткая форма записи a = a / b;
         * %= деление по модулю с присваиванием:
         *      a %= b; --- краткая форма записи a = a % b;
         * */
        int a = 17, b = 7;
        System.out.println("a = " + a + ", b = " + b); // a = 17, b = 7
        a -= b;
        System.out.println("a -= b : a = " + a); // a -= b : a = 10
        a += b;
        System.out.println("a += b : a = " + a); // a += b : a = 17
        a /= b;
        System.out.println("a /= b : a = " + a); // a /= b : a = 2
        a *= b;
        System.out.println("a *= b : a = " + a); // a *= b : a = 14
        a %= b;
        System.out.println("a %= b : a = " + a); // a %= b : a = 0
    }

    private static void comparisonOperatorsDemo() {
        /*
         * В операциях сравнения сравниваются два операнда и возвращается значения типа boolean:
         *  - true, если выражение верно;
         *  - false, если выражение не верно.
         *
         * >  больше (строгое неравенство)
         * <  меньше (строгое неравенство)
         * == равно
         * != не равно
         * >= больше либо равно (нестрогое неравенство)
         * <= меньше либо равно (нестрогое неравенство)
         * */
        System.out.println("8 > 10 : " + (8 > 10)); // 8 > 10 : false
        System.out.println("8 >= 8 : " + (8 >= 8)); // 8 >= 8 : true
        System.out.println("8 != 0 : " + (6 != 0)); // 6 != 0 : true
        System.out.println("15 == 10 + 5 : " + (15 == 10 + 5)); // 15 == 10 + 5 : true
    }

    private static void logicalOperatorsDemo() {
        /*
         * Логические операторы
         * Применяются к значениями типа boolean (или переменным / выражениям, принимающим значения boolean)
         * В результате так же возвращают значение типа boolean
         * && "ленивое" пересечение; логическое И.
         *      a && b --- возвращает true, если оба операнда истинны; возвращает false в ином случае.
         *      если a ложно, b не вычисляется
         * &  пересечение; логическое И.
         *      a & b  --- возвращает true, если оба операнда истинны; возвращает false в ином случае.
         *      оба операнда вычисляются в любом случае
         * || "ленивое" объединение; логическое ИЛИ.
         *      a || b --- возвращает true, если хотя бы один из операднов истинен;
         *                 возвращает false если оба операнда ложны
         *      если a истинно, b не вычисляется
         * |  объединение; логическое ИЛИ.
         *      a | b  --- возвращает true, если хотя бы один из операндов истинен;
         *                 возвращает false если оба операнда ложны
         *     оба операнда вычисляются в любом случае.
         * !  отрицание; логическое НЕ. Применяется к одному операнду.
         *      !a     --- возвращает true, если a ложно; возвращает false, если a истинно.
         * ^  логическое ИСКЛЮЧАЮЩЕЕ ИЛИ; XOR.
         *      a ^ b  --- возвращает true, если строго один из операндов истинен, а второй ложен;
         *                 возвращает false, если оба операнда истинны;
         *                 возвращает false, если оба операнда ложны.
         * */
        boolean a = true, b = false;
        System.out.println(a + " && " + b + " = " + (a && b)); // true && false = false
        System.out.println(a + " && " + a + " = " + (a && a)); // true && true = true
        System.out.println(a + " || " + b + " = " + (a || b)); // true || false = true
        System.out.println(b + " || " + b + " = " + (b || b)); // false || false = false
        System.out.println(a + " ^ " + b + " = " + (a ^ b)); // true ^ false = true
        System.out.println("!" + a + " = " + !a); // !true = false
    }

    private static void bitwiseOperatorsDemo() {
        /*
         * Побитовые операторы.
         * Побитовые операторы применяются только к целочисленным примитинвым типам (byte, short, int, long, char).
         *
         * В отличие от остальных перечисленных операторов, побитовые операторы работают не со значением переменной
         * целиком, а с каждым из его битов последовательно (побитово).
         * Все целочисленные типы хранятся в виде последовательности двоичных бит (8, 16, 32, 64, 16) соответственно.
         * Каждая позиция последовательности представляет степень числа 2.
         *
         * Чтобы получить представление числа в виде последовательности бит можно использовать метод
         * toBinaryString() класса Integer или Long (в зависимости от интересующего типа данных: в Long поместится всё;
         * в Integer - всё, кроме long).
         * */
        int someInt = 42;
        String stringInt = Integer.toBinaryString(someInt);
        System.out.println(someInt + " = " + stringInt); // 42 = 101010
        /*
         * Ведущие нули не отображаются.
         * Получить ведущие нули можно использовав форматирование строк.
         * */
        System.out.printf("%3d = %032d\n", someInt, Integer.valueOf(stringInt));
        //  42 = 00000000000000000000000000101010
        /*
         * Знаковые целочисленные типы (byte, short, int, long) могут принимать отрицательные значения. Знак у таких
         * типов данных хранится в первом бите: 0 - значит плюс, а 1 - минус.
         * */
        int someInt1 = -42;
        String stringInt1 = Integer.toBinaryString(someInt);
        System.out.println(someInt1 + " = " + stringInt1);
        // -42 = 11111111111111111111111111010110
        /*
         * Чтобы из 42 получить -42 недостаточно поменять первый бит на 1. Если сравнить два этих представления
         *  42 = 00000000000000000000000000101010
         * -42 = 11111111111111111111111111010110
         * можно увидеть, что отрицательное число из положительного можно получить в два шага: инвертировать (поменять
         * на обратный) каждый бит и прибавить в результату единицу. Обратное тоже верно. Из отрицательного в
         * положительное число преобразуется так же: инвертировать все биты и прибавить единицу к результату.
         *
         * Если теперь сложить эти два числа по правилам двоичной арифметики - в результате получим все биты единицы и
         * плюс ещё 1 надо добавить. Т.е. все биты сделать нулями и добавить ещё один ведущий бит 1.
         * Но следующиего ведущего бита нет, размер числа ограничен. Происходит переполнение числа и остаются только
         * биты-нули. А значит результат сложения - ноль, как и следовало ожидать.
         * */
        /*
         * Возьмём ещё для примера самое большое и самое малое целое (int) число
         * */
        int maxInt = Integer.MAX_VALUE;
        int minInt = Integer.MIN_VALUE;
        System.out.println(" " + maxInt + " = 0" + Integer.toBinaryString(maxInt));
        //  2147483647 = 01111111111111111111111111111111
        System.out.println(minInt + " = " + Integer.toBinaryString(minInt));
        // -2147483648 = 10000000000000000000000000000000
        /*
         * Таким образом, самое больше положительное число - это все биты единицы кроме старшего бита; самое меньшее
         * отрицательное число - наоборот, все биты нули кроме старшего бита.
         * */
        /*
         * Побитовые операторы работают с такими последовательностями битов на низком уровне: перебирают все доступные
         * позиции по порядку и применяют некоторе действие к биту в соответствующей позиции (если применяется к одному
         * операнду) или битам на соответствующих позициях каждого из двух операндов.
         * */

        // Побитовые логические операторы
        /*
         * Поскольку бит может быть только в двух состояниях: 0 или 1, логика работы побитовых операторов пересекается
         * с уже упомянутыми логическими операторами НЕ, И, ИЛИ, ИСКЛЮЧАЮЩЕЕ ИЛИ
         * */
        // Унарный оператор ~ - побитовый НЕ
        /*
         * Оператор ~ проходит по всем битам операнда и в результате складывает инвертированные (изменённые на
         * обратные) биты в соответствующие позиции.
         * */
        int a = 42;
        String binaryA = String.format("%032d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int notA = ~a;
        String binaryNotA = Integer.toBinaryString(notA);
        System.out.println(" a =  " + a + "  " + binaryA + "~a = " + notA + "  " + binaryNotA);
        /*
         *  a =  42  00000000000000000000000000101010
         * ~a = -43  11111111111111111111111111010101
         * */
        /*
         * Как легко заметить, ~a равно -a - 1
         * */

        // Бинарнвый оператор & - побитовое пересечение; побитовый И
        /*
         * Применяется к двум операндам, сравнивает последовательно биты операндов на соответствующих позициях.
         * В результирущий бит кладёт 1 только если оба сравниваемых бита равны 1; в противном случае в результрущий
         * бит складывает 0.
         * */
        a = 42;
        binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int b = 15;
        String binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        int c = a & b;
        String binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("    a = " + a + binaryA + "    b = " + b + binaryB + "a & b = " + c + binaryC);
        /*
         *     a = 42  00101010
         *     b = 15  00001111
         * a & b = 10  00001010
         * */

        // Бинарнвый оператор | - побитовое объединение; побитовый ИЛИ
        /*
         * Применяется к двум операндам, сравнивает последовательно биты операндов на соответствующих позициях.
         * В результирущий бит кладёт 1 если хотя бы один из сравниваемых битов равны 1; если оба нули, то в
         * результрущий бит складывает 0.
         * */
        a = 42;
        binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        b = 15;
        binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        c = a | b;
        binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("    a = " + a + binaryA + "    b = " + b + binaryB + "a | b = " + c + binaryC);
        /*
         *     a = 42  00101010
         *     b = 15  00001111
         * a | b = 47  00101111
         * */

        // Бинарнвый оператор ^ - побитовое исключающее объединение; побитовый ИСКЛЮЧАЮЩИЙ ИЛИ; побитовый XOR
        /*
         * Применяется к двум операндам, сравнивает последовательно биты операндов на соответствующих позициях.
         * В результирущий бит кладёт 1 если хотя бы один из сравниваемых битов равен 1 (то есть если сравниваемые биты
         * - разные); в противном случае в результрущий бит складывает 0.
         * */
        a = 42;
        binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        b = 15;
        binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        c = a ^ b;
        binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("    a = " + a + binaryA + "    b = " + b + binaryB + "a ^ b = " + c + binaryC);
        /*
         *     a = 42  00101010
         *     b = 15  00001111
         * a ^ b = 37  00100101
         * */

        /*
         * Побитовые операторы & | ^ также могут быть применены к переменным (или выражениям) со значением типа
         * boolean.
         * Фактически, упомянутые выше логические операторы & | ^ - это и есть побитовые логические операторы,
         * применённые к типу данных boolean. При этом значение true в операндах и в результате - равносильно биту 1,
         * а значение false - биту 0.
         * */

        // Операторы сдвига
        // Оператор << n - сдвиг влево на указанное количетсво позиций.
        /*
         * Оператор сдвига << 1 сдвигает все биты чилсла на одну позицию влево. Старший бит (слева) при этом выходит за
         * пределы допустимого значения и теряется, в младший бит (справа) записывается 0.
         * Оператор сдвига << n делает то же самое, тольо n раз: сдвигает все биты числа влево на n позиций; старшие
         * (слева) n бит при этом теряются, в младшие n бит (справа) записываются нули.
         * */
        a = 15;
        binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        b = a << 1;
        binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        c = a << 4;
        binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("     a =  " + a + binaryA + "a << 1 =  " + b + binaryB + "a << 4 = " + c + binaryC);
        /*
         *      a =  15  00001111
         * a << 1 =  30  00011110
         * a << 4 = 240  11110000
         * */
        /*
         * Как легко заметить, для небольших чисел сдвиг влево на 1 позицию равносилен умножению на 2; на n позиций -
         * умножению на 2 в стемени n.
         * В силу особенностей бинарной арифметики и архитектуры процессоров такое умножение на 2 гораздо эффективнее,
         * чем привычное арифметическое.
         * С оператором сдвига нужно работать осторожно. Для больших чисел при сдвиге можно потерять значащие биты (не
         * ведущие нули); можно неожиданно получить отрицательное число (когда в старший бит попадёт 1) и т.д.
         * */

        // Оператор >> n - (знаковый) сдвиг вправо на указанное количество позиций.
        /*
         * Сдвиг вправо действует похоже, но есть существенные отличия.
         * При сдвиге вправо на 1 позицию младший (правый) бит, аналогично, выходит за границу числа и теряется, а
         * слева:
         * - старший (знаковый) бит не изменяется;
         * - заполняется второй старший бит (не знаковый);
         * - причём заполняется он тем же значением, что в знаковом бите.
         * Благодаря этому отрицательное число остаётся отрицательным, а положительное - положительным.
         * */
        a = 84;
        binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        b = a >> 1;
        binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        c = a >> 4;
        binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("     a = " + a + binaryA + "a >> 1 = " + b + binaryB + "a >> 4 =  " + c + binaryC);
        /*
         *      a = 84  01010100
         * a >> 1 = 42  00101010
         * a >> 4 =  5  00000101
         * */
        a = -84;
        binaryA = "  " + Integer.toBinaryString(a) + "\n";
        b = a >> 1;
        binaryB = "  " + Integer.toBinaryString(b) + "\n";
        c = a >> 4;
        binaryC = "  " + Integer.toBinaryString(c);
        System.out.println("     a = " + a + binaryA + "a >> 1 = " + b + binaryB + "a >> 4 =  " + c + binaryC);
        /*
         *      a = -84  11111111111111111111111110101100
         * a >> 1 = -42  11111111111111111111111111010110
         * a >> 4 =  -6  11111111111111111111111111111010
         * */
        /*
         * Таким образом, (знаковый) сдвиг вправо на одну позицию равносилен делению числа на 2 нацело (остаток
         * отбрасывается); на n позиций - делению на 2 в степени n нацело.
         * В силу особенностей бинарной арифметики и архитектуры процессоров такое деление на 2 гораздно эффективнее,
         * чем привычное арифметическое.
         * Знаковый сдвиг вправо даёт предсказуемый результат: нет вероятности смены знака числа, нет переполнения;
         * можно только потерять значащие младшие (правые) биты - остаток от производимого деления.
         * */

        // Оператор >>> n - (беззнаковый) сдвиг вправо на указанное количество позиций.
        /*
         * Беззнаковый сдвиг вправо уже полностью аналогичен сдвигу влево (который всегда беззнаковый): все биты числа
         * целиком сдвигаются вправо на n позиций. Младшие (правые) n бит при этом теряются; старшие (левые) n бит -
         * заполняются нулями.
         * */
        a = -84;
        binaryA = "  " + Integer.toBinaryString(a) + "\n";
        b = a >>> 1;
        binaryB = "  0" + Integer.toBinaryString(b) + "\n";
        c = a >>> 24;
        binaryC = String.format("  %032d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("       a =        " + a + binaryA + "a >>>  1 = " + b + binaryB +
                "a >>> 24 =        " + c + binaryC);
        /*
         *        a =        -84  11111111111111111111111110101100
         * a >>>  1 = 2147483606  01111111111111111111111111010110
         * a >>> 24 =        255  00000000000000000000000011111111
         * */

        // Побитовые операторы с присваиванием
        /*
         * Также как у арифметических операторов, у побитовых операторов есть краткая форма записи с присваиванием.
         * &= побитовый И с присваиванием:
         *      a &= b; --- краткая форма записи a = a & b;
         * |= побитовый ИЛИ с присваиванием:
         *      a |= b; --- краткая форма записи a = a | b;
         * ^= побитовый ИСКЛЮЧАЮЩИЙ ИЛИ с присваиванием:
         *      a ^= b; --- краткая форма записи a = a ^ b;
         * <<= сдвиг влево с присваиванием:
         *      a <<= b; --- краткая форма записи a = a << b;
         * >>= сдвиг вправо с присваиванием:
         *      a >>= b; --- краткая форма записи a = a >> b;
         * >>>= беззнаковый сдвиг вправо с присваиванием:
         *      a >>>= b; --- краткая форма записи a = a >>> b;
         * */
    }

    private static void ternaryOperatorDemo() {
        /*
         * Тренарный (условный) оператор.
         * Использует три операнда. Использует синтаксис:
         * переменная = (условие) ? выражение1 : выражение2;
         *  - условие должно принимать значение типа boolean;
         *  - оба выражения должны принимать значение совместимых типов, и совместимого типа с типом переменной
         *  - выражение1 вычисляется и присваивается переменной, если условие истинно;
         *  - выражение2 вычисляется и присваивается переменной, если условие ложно.
         * фактически, запись
         *      переменная = (условие) ? выражение1 : выражение2;
         * является краткой формой записи блока кода
         *      if (условие) {
         *          переменная = выражение1;
         *      } else {
         *          переменная = выражение2;
         *      }
         * */

        int a = 2, b = 3, c;
        c = (a < b) ? a + b : a - b;
        System.out.println("c = " + c); // c = 5

        /*
         * Еана переменная типа int.
         * Если переменная нечётная - умножить её значение на 2; если чётная - поделить на два.
         * Результат вывести в консоль.
         * */
        int n = (int) (Math.random() * 100);
        int result = (n % 2 == 0) ? n = 2 : n * 2;
        System.out.println("n = " + n + "; result = " + result); // n = 5; result = 10
    }
}
