## Операторы

0. [Математические операторы](#math)
    0. [Бнарные арифметические операторы](#binary-math)
    0. [Унарные арифметичекие операторы](#unary-math)
0. [Операторы присваивания](#assignment)
0. [Операторы сравнения](#comparison)
0. [Логические операторы](#logical)
0. [Побитовые операторы](#bitwise)
    0. [О побитовом представлении числа](#binary-numbers)
    0. [Побитовые логические операторы](#bitwise-logical)
        0. [Побитовое отрицание](#bitwise-not)
        0. [Побитовое пересечение](#bitwise-and)
        0. [Побитовое объединение](#bitwise-or)
        0. [Побитовое исключающее объединение](#bitwise-xor)
    0. [Операторы сдвига](#shift)
        0. [Сдвиг влево](#left-shift)
        0. [Сдвиг вправо](#right-shift)
        0. [Беззнаковый сдвиг вправо](#unsigned-right-shift)
    0. [Побитовые операторы с присваиванием](#bitwise-assignment)
0. [Тренарный (условный) оператор](#ternary)

В языке Java встроен набор **операторов** (действий), которые можно применять к различным типам данных. Сущность(-ти), 
на которую(-ые) действуют операторы называются **операндами**.  
Если в операции участвует более одного операнда, все операнды должны быть одинаковых или совместимых типов.

### Математические операторы <a name="math"></a>

#### Бнарные арифметические операторы <a name="binary-math"></a>

Бинарные арифметические операторы (действуют с двумя операндами): 
- `+` - сложение;
- `-` - вычитание;
- `*` - умножение;
- `/` - деление;  
    Для целых чиисел осуществляется деление нацело. Остаток отбрасывается.
- `%` - взятие остатка от деления;
    Применимо как для целых, так и для дробных чисел.

Пример использования:

[`OperatorsDemo.java`][Operators]

    mathOperatorsDemo() {
        /* <code> */
        int a = 17, b = 7;
        System.out.println(a + " + " + b + " = " + (a + b)); // 17 + 7 = 24
        System.out.println(a + " - " + b + " = " + (a - b)); // 17 - 7 = 10
        System.out.println(a + " * " + b + " = " + (a * b)); // 17 * 7 = 119
        System.out.println(a + " / " + b + " = " + (a / b)); // 17 / 7 = 2
        System.out.println(a + " % " + b + " = " + (a % b)); // 17 % 7 = 3
        /* <code> */
    }
    
Чтобы результат операции был числом с плавающей точкой, нужно чтобы либо хотя бы один из операндов был числом с 
плавающей точкой (можно оба), либо результат операции явно привести к нужному типу. Например:

[`OperatorsDemo.java`][Operators]

    mathOperatorsDemo() {
        /* <code> */
        int a = 17, b = 7;
        System.out.println(a + " / (float)" + b + " = " + (a / (float) b)); // 17 / (float)7 = 2.4285715
        System.out.println("(double)(" + a + " / " + b + ") = " + (double) (a / b)); // (double)(17 / 7) = 2.0
        /* <code> */
    }
    
Во втором случае сначала произведено целочисленное деление, а затем результат приведён к `double`.

####  Унарные арифметичекие операторы <a name="unary-math"></a>

Бинарные арифметические операторы (действуют только с одним операндом):
- `+i` - унарный плюс;  
    Не делает ничего. Введён в противовес унарному минусу.  
- `-i` - унарный минус;  
    Инвертирует знак числа `i` (делает из положительного числа отрицательное и наоборот).  
- `i++` - инкремент (постфиксная форма);  
    Сначала возвращает текущее значение `i`, а затем присваивает `i` значение на 1 больше.  
- `++i` - инкремент (префиксная форма);  
    Сначала присваивает `i` значение на 1 больше, а затем возвращает обновлённое значение `i`.  
- `i--` - декремент (постфиксная форма);  
    Сначала возвращает текущее значение `i`, а затем присваивает `i` значение на 1 меньше.  
- `--i` - декремент (префиксная форма).  
    Сначала присваивает `i` значение на 1 меньше, а затем возвращает обновлённое значение `i`.

Результат действия унарных плюса и минуса нужно использовать: передать далее в выражение, или метод, или присвоить 
переменной.
Результат действия инкремента и декремента автоматически присваивается использованному операнду.

Пример использования:

[`OperatorsDemo.java`][Operators]

    mathOperatorsDemo() {
        /* <code> */
        a = 2;
        System.out.println("a = " + a); // a = 2
        a = -a;
        System.out.println("+a = " + +a); // +a = -2 
        System.out.println("-a = " + -a); // -a = 2 
        a = -a;
        System.out.println(a++ - ++a + a++ + a++ + a); 
        // a++ - ++a + a++ + a++ + a = 13
        /* <code> */
    }

Арифметические операторы можно использовать *только с числовыми* типами данных (включая `char`).  
Попытка использовать математические операторы с логическими (`boolean`) или ссылочными типами данных приведёт к ошибке 
компиляции.  
Исключения: 
- Строки (класс `String`): оператор сложения двух строк разрешён - он производит конкатенацию (склеивание) двух строк.
- Классы-обёртки для числовых типов: `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Character`.

### Операторы присваивания <a name="assignment"></a>

Операторы присваивания:
- `=` - присваивание:  
     `a = 12;` - переменной a присвоено значение 12  
- `+=` - сложение с присваиванием:  
     `a += b;` - краткая форма записи `a = a + b;`  
- `-=` - вычитание с присваиванием:  
     `a -= b;` - краткая форма записи `a = a - b;`  
- `*=` - умножение с присваиванием:  
     `a *= b;` - краткая форма записи `a = a * b;`  
- `/=` - деление с присваиванием:  
     `a /= b;` - краткая форма записи `a = a / b;`  
- `%=` - деление по модулю с присваиванием:  
     `a %= b;` - краткая форма записи `a = a % b;`

Оператор присваивания можно использовать для любых типов данных. Необходимо только чтобы оба операнда были совместимых 
типов.  
Операторы присваивания с сокращённой записью можно использовать только с числовыми типами, т.к. по сути это те же 
арифметические операторы, что и выше.

Пример использования:

[`OperatorsDemo.java`][Operators]

    assignmentOperatorsDemo() {
        /* <code> */
        int a = 17, b = 7;
        System.out.println("a = " + a + ", b = " + b); // a = 17, b = 7
        a -= b;
        System.out.println("a -= b : a = " + a); // a -= b : a = 10
        a += b;
        System.out.println("a += b : a = " + a); // a += b : a = 17
        a /= b;
        System.out.println("a /= b : a = " + a); // a /= b : a = 2
        a *= b;
        System.out.println("a *= b : a = " + a); // a *= b : a = 14
        a %= b;
        System.out.println("a %= b : a = " + a); // a %= b : a = 0
        /* <code> */
    }

### Операторы сравнения <a name="comparison"></a>

Операторы сравнения всегда сравнивают между собой два операнда и возвращают значение с типом `boolean`, т.е. `true` 
если сравнение истинно и `false` - если оно ложно.

Операторы сравнения:
- `>` - больше (строгое неравенство);
- `<` - меньше (строгое неравенство);
- `==` - равно;
- `!=` - не равно;
- `>=` - больше либо равно (нестрогое неравенство);
- `<=` - меньше либо равно (нестрогое неравенство).

Операторы `==` и `!=` можно использовать с любыми типами данных.
Операторы `<`, `>`, `<=`, `>=` можно использовать только с типами данных для которых установлено отношение порядка. В 
частности - любые числовые типы данных.

Пример использования: 

[`OperatorsDemo.java`][Operators]

    comparisonOperatorsDemo() {
        /* <code> */
        System.out.println("8 > 10 : " + (8 > 10)); // 8 > 10 : false
        System.out.println("8 >= 8 : " + (8 >= 8)); // 8 >= 8 : true
        System.out.println("8 != 0 : " + (6 != 0)); // 6 != 0 : true
        System.out.println("15 == 10 + 5 : " + (15 == 10 + 5)); // 15 == 10 + 5 : true
        /* <code> */
    }

### Логические операторы <a name="logical"></a>

Логические операторы позволяют сочетать различные проверки (выполнение условий).   
Логические операторы применимы только к типу `boolean` (или его классу-оболочке `Boolean`) и в результате всегда 
возвращают значение типа `boolean`.

Логические операторы:
- `&&` - "ленивое" пересечение; логическое `И`; `AND`;   
    `a && b` - возвращает `true`, если оба операнда истинны; возвращает `false` в ином случае.  
    Если `a` ложно, `b` не вычисляется.
- `&` - пересечение; логическое `И`; `AND`;   
    `a & b` - возвращает `true`, если оба операнда истинны; возвращает `false` в ином случае.  
    Оба операнда вычисляются в любом случае.
- `||` - "ленивое" объединение; логическое `ИЛИ`; `OR`;   
    `a || b` - возвращает `true`, если хотя бы один из операндов истинен; возвращает `false` если оба операнда ложны.  
    Если `a` истинно, `b` не вычисляется.
- `|`  - объединение; логическое `ИЛИ`; `OR`;  
    `a | b` - возвращает `true`, если хотя бы один из операндов истинен; возвращает false если оба операнда ложны.  
    Оба операнда вычисляются в любом случае.
- `!` - отрицание; логическое `НЕ`; `NOT`;  
    Унарный оператор (применяется к одному операнду).  
    `!a` - возвращает `true`, если `a` ложно; возвращает `false`, если `a` истинно.
- `^` - исключающее обхединение; логическое `ИСКЛЮЧАЮЩЕЕ ИЛИ`; `eXclusive OR`; `XOR`.  
    `a ^ b` - возвращает `true`, если строго один из операндов истинен, а второй ложен;  
        возвращает `false`, если оба операнда истинны; возвращает `false`, если оба операнда ложны.

Пример использования:

[`OperatorsDemo.java`][Operators]

    logicalOperatorsDemo() {
        /* <code> */
        System.out.println(a + " && " + b + " = " + (a && b)); // true && false = false
        System.out.println(a + " && " + a + " = " + (a && a)); // true && true = true
        System.out.println(a + " || " + b + " = " + (a || b)); // true || false = true
        System.out.println(b + " || " + b + " = " + (b || b)); // false || false = false
        System.out.println(a + " ^ " + b + " = " + (a ^ b)); // true ^ false = true
        System.out.println("!" + a + " = " + !a); // !true = false
        boolean a = true, b = false;
        /* <code> */
    }

### Побитовые операторы <a name="bitwise"></a>

Побитовые операторы применяются **только** к целочисленным примитинвым типам (`byte`, `short`, `int`, `long`, `char`).

В отличие от остальных перечисленных операторов, побитовые операторы работают не со значением переменной целиком, а с 
каждым из его битов последовательно (побитово).

#### О побитовом представлении числа <a name="binary-numbers"></a>

Все целочисленные типы хранятся в виде последовательности двоичных бит (нулей и единиц). Каждая позиция 
последовательности представляет степень числа 2 (начиная с нулевой степени).

Чтобы получить представление числа в виде последовательности бит, нужно это число делить на 2 с остатком до тех пор 
пока не получится ноль. При каждом действии получившийся остаток записывать справа налево. Например: 
   
    25 / 2 = 12 остаток 1
    12 / 2 =  6 остаток 0
     6 / 2 =  3 остаток 0
     3 / 2 =  1 остаток 1
     1 / 2 =  0 остаток 1
        25 = 11001  
        25 = 2 ^ 4 + 2 ^ 3 + 2 ^ 0  = 16 + 8 + 1

Биты слева называются **старшими** (т.к. они представляют б*о*льшие степени двойки), биты справа называются 
**младшими**. 

В  числе типа `byte` - 8 значащих бит; в `short` и `char` - по 16; в `int` - 32; в `long` - 64 бита.
Отсюда следуюет диапазон их значений: "повышением" типа данных у числа появляется больше старших битов - старших 
степеней двойки.
  
Из-за особенностей архитектуры процессоров, операции с числами эффективней производить в 32-битной арифметике. Поэтому 
в Java результат операции с участием `byte`, `short` или `char` **автоматически** повышается до типа **int** (процессор 
всё равно оперировал с 32 битами и вернул 32 бита результата). (А современные архитектуры процессоров - уже 64-битные).   

Чтобы получить представление числа в виде последовательности бит можно использовать метод `toBinaryString()` класса 
`Integer` или `Long` (в зависимости от интересующего типа данных: в `Long` "поместится" всё; в `Integer` - всё, кроме 
`long`).

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int someInt = 42;
        String stringInt = Integer.toBinaryString(someInt)
        System.out.println(someInt + " = " + stringInt); // 42 = 101010
        /* <code> */
    }

Метод `toBinaryString()` не выдаёт ведущие нули числа, т.к. они не несут информации.  
Получить ведущие нули можно использовав [форматирование строк](BasicInputOutput.md#input): распознать полученное 
двоичное представление как десятичное число и дополнить его спереди нулями до 32 символов. 

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int someInt = 42;
        String stringInt = Integer.toBinaryString(someInt);
        System.out.printf("%3d = %032d\n", someInt, Integer.valueOf(stringInt));
        //  42 = 00000000000000000000000000101010
        /* <code> */
    }

Таким образом, значение переменной `someInt` равное `42` хранится в памяти в виде такой последовательности бит: 
`00000000000000000000000000101010`.

Знаковые целочисленные типы (`byte`, `short`, `int`, `long`) могут принимать отрицательные значения. Знак у таких
типов данных хранится в первом бите: `0` - значит плюс, а `1` - минус.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int someInt1 = -42;
        String stringInt1 = Integer.toBinaryString(someInt);
        System.out.println(someInt1 + " = " + stringInt1);
        // -42 = 11111111111111111111111111010110
        /* <code> */
    }

Таким образом, значение переменной `someInt1` равное `-42` хранится в памяти в виде такой последовательности бит: 
`11111111111111111111111111010110`.

Чтобы из 42 получить -42 недостаточно поменять первый бит на `1`. Если сравнить два этих представления

     42 = 00000000000000000000000000101010
    -42 = 11111111111111111111111111010110

можно увидеть, что отрицательное число из положительного можно получить в два шага: инвертировать (поменять на 
обратный) каждый бит и прибавить в результату единицу.   
Обратное тоже верно. Из отрицательного в положительное число преобразуется так же: инвертировать все биты и прибавить 
единицу к результату.

Возьмём ещё для примера самое большое и самое малое целое (`int`) число (для удобства, их можно взять в константах 
`MAX_VALUE` и `MIN_VALUE` класса `Integer`).

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int maxInt = Integer.MAX_VALUE;
        int minInt = Integer.MIN_VALUE;
        System.out.println(maxInt + " = " + Integer.toBinaryString(maxInt));
        //  2147483647 = 01111111111111111111111111111111
        System.out.println(minInt + " = " + Integer.toBinaryString(minInt));
        // -2147483648 = 10000000000000000000000000000000
        /* <code> */
    }

Таким образом, самое больше положительное число - это все биты единицы кроме старшего бита; самое меньшее отрицательное 
число - наоборот, все биты нули кроме старшего бита.

Теперь можно подробнее пояснить, что происходит при приведении целочисленных типов.  

Как уже показано, у положительного числа *все незначащие старшие биты* - всегда нули; у отрицательного, 
соответственно - всегда единицы. 

Поэтому при **повышении** типа `byte -> short -> int -> long` к числу просто *добавляются старшие биты равные знаковому 
биту*. **Значение** числа при этом **не меняется**: знаковый (первый) бит - имеет то же значение; старшие биты - как 
были незначащими, так и остались.  
Поэтому операция *повышения* целочисленного типа безопасна, потерь даннных быть не  может, и при необходимости она 
выполняется автоматически.  
(Тип `char` беззнаковый - при его повышении всегда в старшие биты добавляются нули).
  
При **понижении** типа `long -> int -> short -> byte` *старшие биты* **отбрасываются**. Поэтому результат отперации 
*понижения* целочисленного типа, **непредсказуем**: нет гарантии, что все отброшенные старшие биты были незначимыми; 
ставший теперь первым (знаковым) бит не обязательно будет тем же, каким был предыдущий знаковый бит, а соответственно, 
может измениться интерпретация всего числа.  
Исключение - случаи, когда мы гарантированно уверены, что хранящееся значение попадает в диапазон целевого типа. Тогда, 
все старшие биты до понижения - незначайщие, и при понижении типа значение не изменится.  
Поэтому в Java понижение типа требуется указывать *явно*, осознавая и принимая ответственность возможной потери / 
искажения данных.

#### Побитовые логические операторы <a name="bitwise-logical"></a>


Побитовые операторы применяются **только** к целочисленным примитинвым типам (`byte`, `short`, `int`, `long`, `char`).

Поскольку бит может быть только в двух состояниях: `0` или `1`, логика работы побитовых операторов пересекается с уже 
описанными логическими операторами `НЕ`, `И`, `ИЛИ`, `ИСКЛЮЧАЮЩЕЕ ИЛИ`

##### Побитовое отрицание <a name="bitwise-not"></a>

Унарный оператор `~` - **побитовое отрицание**; побитовый `НЕ`; `NOT`.  
Оператор `~` проходит по всем битам операнда и в результат кладёт инвертированные (изменённые на противоположные) 
биты в соответствующие позиции.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = 42;
        String binaryA = String.format("%032d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int notA = ~a;
        String binaryNotA = Integer.toBinaryString(notA);
        System.out.println(" a =  " + a + "  " + binaryA + "~a = " + notA + "  " + binaryNotA);
        /*
         *  a =  42  00000000000000000000000000101010
         * ~a = -43  11111111111111111111111111010101
         * */
        /* <code> */
    }

Как легко заметить, `~a` равно `-a - 1`.

##### Побитовое пересечение <a name="bitwise-and"></a>

Бинарнвый оператор `&` - **побитовое пересечение**; побитовый `И`; `AND`.  
Оператор `&` применяется к двум операндам, сравнивает последовательно биты операндов на соответствующих позициях. В 
результирущий бит кладёт `1` только если оба сравниваемых бита равны `1`; в противном случае в результрущий бит 
кладёт `0`.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = 42;
        String binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int b = 15;
        String binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        int c = a & b;
        String binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("    a = " + a + binaryA + "    b = " + b + binaryB + "a & b = " + c + binaryC);
        /*
         *     a = 42  00101010
         *     b = 15  00001111
         * a & b = 10  00001010
         * */
        /* <code> */
    }

##### Побитовое объединение <a name="bitwise-or"></a>

Бинарнвый оператор `|` - **побитовое объединение**; побитовый `ИЛИ`; `OR`.  
Оператор `|` применяется к двум операндам, сравнивает последовательно биты операндов на соответствующих позициях. В 
результирущий бит кладёт `1`, если хотя бы один из сравниваемых битов равны 1; если оба нули, то в
результрущий бит кладёт `0`.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = 42;
        String binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int b = 15;
        String binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        int c = a | b;
        String binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("    a = " + a + binaryA + "    b = " + b + binaryB + "a | b = " + c + binaryC);
        /*
         *     a = 42  00101010
         *     b = 15  00001111
         * a | b = 47  00101111
         * */
        /* <code> */
    }

##### Побитовое исключающее объединение <a name="bitwise-xor"></a>

Бинарнвый оператор `^` - **побитовое исключающее объединение**; побитовый `ИСКЛЮЧАЮЩИЙ ИЛИ`; побитовый `XOR`.  
Оператор `^` применяется к двум операндам, сравнивает последовательно биты операндов на соответствующих позициях.
В результирущий бит кладёт `1` если хотя бы один из сравниваемых битов равен `1` (то есть, если сравниваемые биты - 
разные); в противном случае в результрущий бит клдаёт `0`.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = 42;
        String binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int b = 15;
        String binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        int c = a ^ b;
        String binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("    a = " + a + binaryA + "    b = " + b + binaryB + "a ^ b = " + c + binaryC);
        /*
         *     a = 42  00101010
         *     b = 15  00001111
         * a ^ b = 37  00100101
         * */
        /* <code> */
    }

Побитовые операторы `&`, `|` и `^` также могут быть применены к переменным (или выражениям) со значением типа 
`boolean`. 
Фактически, упомянутые выше *логические операторы* `&`, `|` и `^` - это и есть побитовые логические операторы, 
применённые к типу данных `boolean`. При этом значение `true` в операндах и в результате - равносильно биту `1`, а 
значение `false` - биту `0`.

#### Операторы сдвига <a name="shift"></a>

##### Сдвиг влево <a name="left-shift"></a>

Оператор `<< n` - **сдвиг влево** на указанное количетсво (`n`) позиций.  
Оператор сдвига `<< 1` *сдвигает все биты* чилсла *на одну позицию влево*. Старший бит (слева) при этом выходит за
пределы допустимого значения и *теряется*, в младший бит (справа) записывается `0`.  
Оператор сдвига `<< n` делает то же самое, тольо `n` раз: *сдвигает все биты* числа *влево на* `n` *позиций*; старшие
(слева) `n` бит при этом теряются, в младшие `n` бит (справа) записываются нули.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = 15;
        String binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int b = a << 1;
        String binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        int c = a << 4;
        String binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("     a =  " + a + binaryA + "a << 1 =  " + b + binaryB + "a << 4 = " + c + binaryC);
        /*
         *      a =  15  00001111
         * a << 1 =  30  00011110
         * a << 4 = 240  11110000
         * */
        /* <code> */
    }

Как легко заметить, для небольших чисел сдвиг влево на 1 позицию *равносилен умножению на 2*; на `n` позиций -
умножению на 2 в стемени `n`.  
В силу особенностей бинарной арифметики и архитектуры процессоров такое умножение на 2 **гораздо эффективнее**,
чем привычное арифметическое.  
С оператором сдвига нужно работать осторожно. Для больших чисел при сдвиге можно потерять значащие биты (не
ведущие нули); можно неожиданно получить отрицательное число (когда в старший бит попадёт 1) и т.д.

##### Сдвиг вправо <a name="right-shift"></a>

Оператор `>> n` - (знаковый) **сдвиг вправо** на указанное количество позиций.  
Сдвиг вправо действует похоже, но есть существенные отличия.
При *сдвиге вправо всех битов* на 1 позицию младший (правый) бит, аналогично, выходит за границу числа и теряется, а
слева:
- **знаковый** (старший) бит **не изменяется**;
- заполняется *второй* старший бит (не знаковый);
- причём заполняется он *тем же значением, что в знаковом бите*.  

Благодаря этому отрицательное число остаётся отрицательным, а положительное - положительным. Сохраняется знак числа. 
Поэтому этот оператор сдвига часто называют **знаковым** сдвигом вправо.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = 84;
        String binaryA = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(a)));
        int b = a >> 1;
        String binaryB = String.format("  %08d\n", Integer.valueOf(Integer.toBinaryString(b)));
        int c = a >> 4;
        String binaryC = String.format("  %08d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("     a = " + a + binaryA + "a >> 1 = " + b + binaryB + "a >> 4 =  " + c + binaryC);
        /*
         *      a = 84  01010100
         * a >> 1 = 42  00101010
         * a >> 4 =  5  00000101
         * */
        a = -84;
        binaryA = "  " + Integer.toBinaryString(a) + "\n";
        b = a >> 1;
        binaryB = "  " + Integer.toBinaryString(b) + "\n";
        c = a >> 4;
        binaryC = "  " + Integer.toBinaryString(c);
        System.out.println("     a = " + a + binaryA + "a >> 1 = " + b + binaryB + "a >> 4 =  " + c + binaryC);
        /*
         *      a = -84  11111111111111111111111110101100
         * a >> 1 = -42  11111111111111111111111111010110
         * a >> 4 =  -6  11111111111111111111111111111010
         * */
        /* <code> */
    }
    
Таким образом, (знаковый) *сдвиг вправо* на одну позицию *равносилен делению числа на 2* нацело (остаток 
отбрасывается); на `n` позиций - делению на 2 в степени `n` нацело.  
В силу особенностей бинарной арифметики и архитектуры процессоров такое деление на 2 **гораздно эффективнее**, чем 
привычное арифметическое.  
Знаковый сдвиг вправо даёт *предсказуемый результат*: нет вероятности смены знака числа, нет переполнения; можно только 
потерять значащие младшие (правые) биты - остаток от производимого деления, что ожидаемо.

##### Беззнаковый сдвиг вправо <a name="unsigned-right-shift"></a>

Оператор `>>> n` - **беззнаковый сдвиг вправо** на указанное количество позиций.  
*Беззнаковый сдвиг вправо* уже полностью аналогичен *сдвигу влево* (который всегда беззнаковый): все биты числа целиком 
*сдвигаются вправо* на `n` позиций. Младшие (правые) `n` бит при этом *теряются*; старшие (левые) `n` бит - 
*заполняются нулями*.

[`OperatorsDemo.java`][Operators]

    bitwiseOperatorsDemo() {
        /* <code> */
        int a = -84;
        String binaryA = "  " + Integer.toBinaryString(a) + "\n";
        int b = a >>> 1;
        String binaryB = "  0" + Integer.toBinaryString(b) + "\n";
        int c = a >>> 24;
        String binaryC = String.format("  %032d", Integer.valueOf(Integer.toBinaryString(c)));
        System.out.println("       a =        " + a + binaryA + "a >>>  1 = " + b + binaryB +
                "a >>> 24 =        " + c + binaryC);
        /*
         *        a =        -84  11111111111111111111111110101100
         * a >>>  1 = 2147483606  01111111111111111111111111010110
         * a >>> 24 =        255  00000000000000000000000011111111
         * */
        /* <code> */
    }
    
Из-за возможной смены *знакового* (первого) бита при *беззнаковом сдвиге вправо* возможна потеря данных, как и при 
*сдвиге влево*.

#### Побитовые операторы с присваиванием <a name="bitwise-assognment"></a>

Также как у арифметических операторов, у побитовых операторов есть краткая форма записи с присваиванием:
- `&=` побитовый `И` с присваиванием:  
     `a &= b;` - краткая форма записи `a = a & b;`  
- `|=` побитовый `ИЛИ` с присваиванием:  
     `a |= b;` - краткая форма записи `a = a | b;`  
- `^=` побитовый `ИСКЛЮЧАЮЩИЙ ИЛИ` с присваиванием:
     `a ^= b;` - краткая форма записи `a = a ^ b;`  
- `<<=` сдвиг влево с присваиванием:  
     `a <<= b;` - краткая форма записи `a = a << b;`
- `>>=` сдвиг вправо с присваиванием:  
     `a >>= b;` - краткая форма записи `a = a >> b;`
- `>>>=` беззнаковый сдвиг вправо с присваиванием:  
     `a >>>= b;` - краткая форма записи `a = a >>> b;`

### Тернарный (условный) оператор <a name="ternary"></a>

Использует три операнда. Использует синтаксис:

    переменная = (условие) ? выражение1 : выражение2;

- условие должно принимать значение типа `boolean`;
- оба `выражения` должны принимать значение совместимых типов, и совместимого типа с типом `переменной`;
- `выражение1` вычисляется и присваивается переменной, если `условие` истинно;
- `выражение2` вычисляется и присваивается переменной, если `условие` ложно.

Фактически, запись

     переменная = (условие) ? выражение1 : выражение2;

является краткой формой записи блока кода ([условного оператора `if`](../l02choicesloops/ConditionalStatements.md#if))

     if (условие) {
         переменная = выражение1;
     } else {
         переменная = выражение2;
     }

<!--  ------------------------------  -->
[Operators]: OperatorsDemo.java
