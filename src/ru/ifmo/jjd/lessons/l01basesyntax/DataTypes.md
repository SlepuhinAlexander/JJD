## Типы данных

### Содержание

1. [Переменные](#1-)
2. [О типах данных](#2---)
3. [Объявление и использование переменных](#3----)
4. [Именование переменных](#4--)
5. [Примитивные типы данных](#5---)
    1. [Тип `byte`](#51--byte)
    2. [Тип `short`](#52--short)
    3. [Тип `int`](#53--int)
    4. [Тип `long`](#54--long)
    5. [Тип `float`](#55--float)
    6. [Тип `double`](#56--double)
    7. [Тип `char`](#57--char)
    8. [Тип `boolean`](#58--boolean)
6. [Приведение типов](#6--)
    1. [Автоматическое приведение типов](#61---)
    2. [Повышение типа при математических операциях](#62-----)
    3. [Явное приведение типов](#63---)


### 1. Переменные

Каждая программа в конечном итоге сводится к манипулированию некоторыми данными. Для того, чтобы осуществлять эти 
манипуляции, данные должны быть где-то сохранены.  
Все данные, используемые программой на Java хранятся в *переменных*.  
**Переменная** - это *именованная* область оперативной памяти, используемая для хранения данных определённого типа. 
Доступ к даннам (на чтение и на запись) осуществляется по имени переменной.  

### 2. О типах данных

Каждая переменная принадлежит к какому-то **типу данных**, определяющему, какие данные могут в этой переменной 
храниться.   
Язык Java является **строго типизированным**. Это означает, что переменные определённого типа могут хранить данные 
только этого типа. Проверка соответствия типов осуществляется как статически, компилятором, до запуска программы, так 
и динамически, во время исполнения программы.

Все типы данных, имеющиеся в языке Java делятся на две группы: **примитивные** типы (встроенные непосредственно в язык) 
и **ссылочные** типы (являющиеся ссылками на объекты). 

Примитивных типов данных в Java всего 8:
- целочисленные:
    - byte
    - short
    - int
    - long
- дробные (числа с плавающей точкой):
    - float
    - double
- логические: 
    - boolean
- символьные:
    - char
    
Ссылочыных типов может быть создано неограниченное количество. Ссылочными типами являются:
- String (строки);
- Массивы;
- Любые классы и интерфейсы уже реализованные в платформе Java;
- Любые новые классы и интерфейсы, сконструированные пользователем (программистом).

### 3. Объявление и использование переменных

Все переменные должны быть *объявлены* перед тем как использоваться. **Объявление** переменной - это инструкция, 
которая состоит из указания *типа данных* и *имени переменной*. Например:

    byte byteVar;
    
это посто объявление переменной `byteVar`, выделение области памяти под неё. Значение переменной byteVar не определено 
(попытка прочитать это значение вызовет ошибку компиляции).  
Объявлять можно и одновременно несколько переменных одного типа:

    byte byteVar1, byteVar2;
    
Объявленной переменной можно *присвоить значение*:

    byteVar = 10;

Значение, разумеется, можно изменить: для этого нужно просто присвоить новое значение (*переопределить* его):

    byteVar = 12;
    
Присвоить значение переменной, можно и сразу в момент объявление (*инициализировать* её). 

    byte byteVar3 = 35;

Это также верно и для нескольких переменных одного типа:

    byte byteVar4 = 20, byteVar5 = 17;
    
Переменной можно присваивать не только конкретное значение, но и значение другой переменной (того же или совместимого 
типа):

    byte byteVar6 = byteVar;
    
значение выражения (см [Операторы присваивания](Operators.md#2--)):

    byte byteVar7 = byteVar4 - byteVar3 + 111;

результат выполнения метода (если он возвращает результат того же или совместимого типа):

    int intVar = Math.min(3, 5);
    
Чтобы считать значение переменной достаточно обратиться к ней по её имени. Например, чтобы вывести значение переменной 
в консоль, её нужно передать в метод `System.out.println()`.  
Инструкция `System.out.println();` вызывает метод печати в консоль того, что будет передано ему в аргумент (внутрь) 
скобок (подробнее см в [вывод в консоль](BasicInputOutput.md#1---)).  

[`DataTypesDemo.java`][DataTypes]

    variablesDemo() {
        /* <code> */
        System.out.println("byteVar: " + byteVar); // byteVar: 12
        // Вывести значение переменных byteVar1, byteVar2 невозможно:
        //   они не инициализированы (им не присвоены значения)
        System.out.println("byteVar3: " + byteVar3); // byteVar3: 35
        System.out.println("byteVar4: " + byteVar4); // byteVar4: 20
        System.out.println("byteVar5: " + byteVar5); // byteVar5: 17
        System.out.println("byteVar6: " + byteVar6); // byteVar6: 12
        System.out.println("byteVar7: " + byteVar7); // byteVar7: 96
        System.out.println("intVar: " + intVar); // intVar: 3
        /* <code> */
    }
    
### 4. Именование переменных

Имена переменных должны удовлетворять ряду требований. Требования можно разделить на *обязательные* и *рекомендуемые*.   
Нарушение *обязательного* требования является *синтаксической ошибкой*, такой код не скомпилируется.   
Рекомендуемые требования входят в Соглашение по именованию (Java Code Conventions), призванное сделать код на Java 
единообразным и удобочитаемым. Нарушение рекомендуемых требований ошибкой синтаксиса не является, но делает код менее 
читаемым и менее привычным другим программистам.

Обязательные требования:
- имя переменной должно *начинаться* с буквы латинского алфавита, знака `$` или `_` (подчёркивания);     
- имя переменной должно состоять из букв (Unicode символов), цифр, знака `_`. Технически, можно использовать буквы 
    любого алфавита (кроме первого символа);
- имя переменной является одним словом, пробельные символы не допускаются;
- имя переменной не должно совпадать с зарезервированным ключевым словом языка Java;
- имя переменной должно быть уникально в пределах своей видимости;
- имя переменной чувствительно к регистру: `byteVar` и `bytevar` - это два разных имени.

Рекомендуемые требования:
- не использовать `$` или `_` в качестве первого символа имени переменной (т.е. начинать только с латинской буквы);
- не использовать `$` вообще;
- первым символом имени использовать букву латинского алфавита в нижнем регистре. Это необходимо для разделение имён 
    переменных и имён классов: все переменные именуются со строчной буквы, а все классы и интерфейсы - с заглавной;
- при выборе имён следует использовать полные слова, отражающие суть данных, хранящихся в этой переменной;
- использовать camelCase нотацию: если имя переменной состоит из нескольких слов (что вполне допустимо), то необходимо 
   их использовать слитно, каждое следующее слово начиная с заглавной буквы. Намриер: 
   `weirdRidiculouslyLongVariableName`.

### 5. Примитивные типы данных

#### 5.1. Тип `byte`

Тип `byte` хранит целое число в диапазоне от -128 до 127. Значение по умолчанию равно 0.  
Занимает 1 байт памяти (8 бит). Соответственно, имеет 2 ^ 8 = 256 вариантов состояния.

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        byte byteVar = 35, byteVar1 = -17;
        System.out.println("byteVar: " + byteVar); // byteVar: 35
        System.out.println("byteVar1: " + byteVar1); // byteVar: -17
        /* <code> */
    }

#### 5.2. Тип `short`

Тип `short` хранит целое число число в диапазоне от -32 768 до 32 767. Значение по умолчанию равно 0.  
Занимает 2 байта памяти (16 бит). Соответственно, имеет 2 ^ 16 = 65 536 вариантов состояния.

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        short shortVar = 300, shortVar1 = 200;
        System.out.println("shortVar: " + shortVar); // shortVar: 300
        System.out.println("shortVar1: " + shortVar1); // shortVar1: 200
        /* <code> */
    }
    
#### 5.3. Тип `int`

Тип `int` хранит целое число в диапазоне от -2 147 483 648 до 1 124 483 647. Значение по умолчанию равно 0.
Занимает 4 байта памяти (32 бита). Соответственно, имеет 2 ^ 32 = 4 294 967 296 вариантов состояния.  

Конкретное значение, которое используется в коде: в выражениях, присваивается переменным, - называется **литерал**. 
В данном случае, использованные целочисленные значения есть целочисленные литералы.  
Начиная с Java 7 в целочисленных литералах разрешено использовать символ `_` для визуального разделения групп разрядов. 
Компилятор эти символы игнорирует. 

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        int intVar = 1000;
        int intVar1 = 1_000_000;
        System.out.println("intVar: " + intVar); // intVar: 1000
        System.out.println("intVar1: " + intVar1); // intVar1: 1000000
        /* <code> */
    }
    
Все целочисленные литералы в исходном коде по умолчанию интерпретируются как тип данных `int`. Поэтому обе инструкции

    byte bigByte = 1_000_000;
    short bigShort = 1_000_000;

приведут к ошибке компиляции: `incompatible types: possible lossy conversion from int to byte` (`from int to short`). 
Тип данных `int` нельзя просто так поместить в м*е*ньший тип данных `short` или `byte`, т.к. значение выходит за рамки 
допустимого диапазона.

Более того, арифметические операции с использованием типов данных `byte` и/или `short` используют 32-битную арифметику 
и, следовательно, дают результат с типом данных `int`. Поэтому инструкции

    byte byteSum = byteVar + byteVar1;
    short shortSum = shortVar + shortVar1;

также приведут к ошибке компиляции: `incompatible types: possible lossy conversion from int to byte` (`from int to 
short`). Чтобы избежать ошибки, результат таких операций можно присваивать переменным типа `int`:

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        int shortSum = shortVar + shortVar1;
        int byteSum = byteVar + byteVar1;
        System.out.println("byteSum: " + byteSum); // byteSum: 18
        System.out.println("shortSum: " + shortSum); // shortSum: 500
        /* <code> */
    }
    
#### 5.4. Тип `long`

Тип `long` является самым "большим" целочисленным типом данных. Он хранит целое число в диапазоне от 
-9 223 372 036 854 775 808 до 9 223 372 036 854 775 807. Значение по умолчанию равно 0.  
Занимает 8 байт (64 бита). Соответственно, имеет 2 ^ 64 = 18 446 744 073 709 551 616 вариантов состояния.

Целочисленные литералы по умолчанию - не подходят для работы с типом данных `long`. Инструкция:

    long longVar = 3_000_000_000;
    
приведёт к ошибке компиляции: `integer number too large` (ещё до присвоения значения переменной), поскольку переданное 
число будет интерпретировано как `int`, а его значение "не помещается" в диапазон значений типа `int`.  
Чтобы указать компилятору, что литерал должен использоваться именно как тип `long` необходимо добавить к нему символ 
`l` или `L`. Лучше использовать заглавную букву, т.к. `l` легко спутать с `1`.

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        long longVar = 3_000_000_000L;
        System.out.println("longVar: " + longVar); // longVar: 3000000000
        /* <code> */
    }
    
Для всех целочисленных типов арифметические операции дают *целочисленный* результат. Операция *деления* для 
целочисленных данных так же даёт *целый* результат: возвращается целая часть от деления (неполное частное), а остаток 
от деления отбрасывается.

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("8 / 3 = " + 8 / 3); // 8 / 3 = 2
        System.out.println("-11 / 7 = " + -11 / 7); // -11 / 7 = -1
        /* <code> */
    }

Целочисленное деление на ноль приводит к ошибке (значение такого действия не определено):

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("8 / 0 = " + 8 / 0); // ошибка времени исполнения: ArithmeticException: / by zero
        /* <code> */
    }
    
Для работы с *большими числами*, для которых не подойдут примитивные типы, рекомендуется использовать служебный 
класс `java.math.BigInteger`.

#### 5.5. Тип `float`

Числа с плавающей точкой применяются при вычислений выражений, в которых требуется точность для некоторого десятичного 
знака. Тип `float` ещё называют числом с плавающей точкой - *одинарной точности*.

Тип `float` хранит дробное число (десятичную дробь) в формате числа с плавающей точкой. Диапазон значений от 1.4E-45 до 
3.4E38 без учёта знака (такой же диапазон для отрицательных значений).  
Кроме того, может принимать значения +0.0, -0.0, Positive Infinity, Negative Infinity, NaN (not a number).   
Значение по умолчанию равно 0.0.  
Занимает 4 байта (32 бита). 

Инструкция 
    
    float floatVar = 1;
    
приведёт к ошибке компиляции: `incompatible types: possible lossy conversion from int to float`, потому что 
целочисленный литерал интерпретируется как `int`, а `int` по умолчанию не совместим с типом `float`.

Инструкция
    
    float floatVar = 1.0;
    
тоже приведёт к ошибке компиляции: `incompatible types: possible lossy conversion from double to float`, потому что 
*дробный* литерал интерпретируется как тип `double`, который больше чем `float` по диапазону допустимых значений.

Чтобы указать компилятору, что литерал должен использоваться именно как тип `float` неободимо добавить к нему символ 
`f` или `F`.

    float floatVar = 1f, floatVar1 = 5.7f;

Для чисел с плавающей точкой можно использовать *экспоненциальную запись* литерала:

    float floatVar2 = -2.3e3F, floatVar3 = 0.044E-5F;
    
используя символ `e` или `E`, за которым следует значение экспоненты числа.

Числа с плавающей точкой хранятся в *нормализованном* виде: первый символ всегда 0, далее следует опрелеённое 
количество значащих разрядов после запятой (зависит от типа данных, у `double` - больше), и следует экспонента числа 
(положительная или отрицательная). 

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("floatVar: " + floatVar); // 1.0
        System.out.println("floatVar1: " + floatVar1); // 5.7
        System.out.println("floatVar2: " + floatVar2); // -2300.0
        System.out.println("floatVar3: " + floatVar3); // 4.4E-7
        /* <code> */
    }

#### 5.6 Тип `double`

Тип `double` хранит дробное число (десятичную дробь) в формате числа с плавающей точкой - *двойной точности*. Диапазон 
значений от 4.9E-324 до 1.79E308 без учёта знака (такой же диапазон для отрицательных значений).  
Кроме того, может принимать значения +0.0, -0.0, Positive Infinity, Negative Infinity, NaN (not a number).   
Значение по умолчанию равно 0.0.  
Занимает 8 байт (64 бита). 

Инструкция 
    
    double doubleVar = 2; 

не приведёт к ошибке, т.к. тип `int` совместим с `double` ("помещается" в него).  
Для задания значения переменной типа `double` можно использовать дробное число в обычной и экспоненциальной записи

    double doubleVar = 2.0, doubleVar1 = 2.7E3;
    
Аналогично типам данных `long` и `float`, можно явно указать компилятору, что литерал должен интерпретироваться как тип 
`double`: для этого можно добавить к нему символ `d` или `D`, но это не обязательно:

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        double doubleVar2 = 1d, doubleVar3 = -0.033E-3D;
        System.out.println("doubleVar: " + doubleVar); // 2.0
        System.out.println("doubleVar1: " + doubleVar1); // 2700.0
        System.out.println("doubleVar2: " + doubleVar2); // 1.0
        System.out.println("doubleVar3: " + doubleVar3); // -3.3E-5
        /* <code> */
    }

Для типов `float` и `double` арифметические операции дают соответствующий результат: `float` или `double`

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("floatVar1 + floatVar3 = " + (floatVar1 + floatVar3)); // floatVar1 + floatVar3 = 5.7000003
        System.out.println("doubleVar * doubleVar1 = " + doubleVar * doubleVar1); // doubleVar * doubleVar1 = 5400.0
        System.out.println("doubleVar2 / doubleVar = " + doubleVar2 / doubleVar); // doubleVar2 / doubleVar = 0.5
        /* <code> */
    }

Деление на ноль в числах с плавающей точкой - допустимо:

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        double zero = 0D;
        System.out.println("doubleVar / zero = " + doubleVar / zero); // doubleVar / zero = Infinity
        System.out.println("doubleVar3 / zero = " + doubleVar3 / zero); // doubleVar3 / zero = -Infinity
        /* <code> */
    }

Деление нуля на ноль даёт в результате неопределённость `NaN` (not a number):

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("zero / zero = " + zero / zero); //zero / zero = NaN
        /* <code> */
    }

Арифметические операции с числами `float` и `double` дают **приблизительный** результат:

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("2.0 - 1.1 = " + (2.0 - 1.1)); // 2.0 - 1.1 = 0.8999999999999999
        System.out.println("0.1 + 0.1 + 0.2 + 0.2 = " + (0.1 + 0.1 + 0.2 + 0.2)); 
        // 0.1 + 0.1 + 0.2 + 0.2 = 0.6000000000000001
        /* <code> */
    }
 
Для **точных** вычислений использовать эти типы данных некорректно. Для работы с точными вычислениями рекомендуется 
использовать служебный класс `java.math.BigDecimal`.

#### 5.7. Тип `char`

Тип `char` хранит один Unicode-символ (в кодировке UTF-16). Фактически, хранит целое беззнаковое число: численный код 
символа.  
Диапазон значений `char`: от 0 до 65535 (от '\u0000' до '\uFFFF'). Значение по умолчаниню равно 0.  
Занимает 2 байта (16 бит).

Для присвоения переменной типа `char` значения можно использовать код символа:

    char charVal = 74;

непосредственно сам симол, вводимый с клавиатуры (в одинарных кавычках):

    char charVal1 = 'a';
    
или Unicode-символ в виде шестнадцатеричной escape-последовательности:

    char charVal2 = `\u0076`;

Escape-последовательность состоит из:
- записи `\u`, означающей что далее следует Unicode-символ;
- далее следует 4-значное число в 16-ричной системе счисления (от 0000 до FFFF), равное коду символа;
- вся последовательность заключается в одинарные кавычки как один символ.

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        System.out.println("" + charVal + charVal1 + charVal2 + charVal1); // Java
        /* <code> */
    }

Поскольку тип данных `char` фактически хранит целое число, с ним допустимы целочисленные арифметические операции:

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        char java = 'J' + 'a' + 'v' + 'a';
        System.out.println("java = " + java); // java = Ƃ
        char character = 'c' + 'h' + 'a' + 'r' + 'a' + 'c' + 't' + 'e' + 'r';
        System.out.println("character = " + character); // character = έ
        /* <code> */
    }

#### 5.8. Тип `boolean`

Тип `boolean` явлается логическим типом, и может иметь только два значения: `true` (истина) или `false` (ложь).  
Эти значения именно `true` и `false`, а не 1 и 0, как в некоторых других языках программирования. В Java тип `boolean` 
не совместим с численными типами, и соответсвтенно, не может участовать с ними в арифметических операциях.

Тип `boolean` используется в управляющих конструкциях (ветвлениях кода), когда дальнейшие действия программы зависят 
от результата проверки какого-то условия: истинно оно или ложно. Операторы сравнения тоже всегда возвращают результат 
типа `boolean`. 

Занимаемое количество памяти типом `boolean` не фиксировано, зависит от реализации конкретной JVM.

[`DataTypesDemo.java`][DataTypes]

    dataTypesDemo() {
        /* <code> */
        boolean isActive = true;
        boolean isClosed = false;
        System.out.println("Is active? " + isActive); // Is active? true
        System.out.println("Is closed? " + isClosed); // Is closed? false
        /* <code> */
    }

### 6. Приведение типов 

*Совместимые* типы данных возможно приводить один к другому. Существует два варианта приведения типов:
- автоматическое приведение (производится без участия программиста, самостоятельно, динамически)
- явное (принудительное) приведение.

#### 6.1. Автоматическое приведение типов

Автоматическое приведение типов осуществляется если оба типа совместимы и целевой тип имеет большую вместимость 
диапазона, чем исходный. При этом преобразование может быть как без потерь, так и с возможной потерей данных 
(точности).

Без потерь "помещается":
- `float` в `double`;
- `int` в `long` или `double`;
- `char` в `int` и, следовательно, в `long` или `double`;
- `short` в `int` и, следовательно, в `long` или `double`;
- `byte` в `short` и, следовательно, в `int`, `long` или `double`.

[`DataTypesDemo.java`][DataTypes]

    typesCastDemo() {
        /* <code> */
        byte byteVal = 15;
        short shortVal = byteVal; 
        int intVal = byteVal, intVal1 = shortVal; 
        long longVal = byteVal, longVal1 = shortVal, longVal2 = intVal; 
        double doubleVal = intVal; 
        float floatVal = 1.0f;
        double doubleVal1 = floatVal;
        System.out.println("byte = " + byteVal); // byte = 15
        System.out.println("byte to short = " + shortVal); // byte to short = 15
        System.out.println("short to int = " + intVal1); // short to int = 15
        System.out.println("int to long = " + longVal2); // int to long = 15
        System.out.println("int to double = " + doubleVal); // int to double = 15.0
        System.out.println("float to double = " + doubleVal1); // float to double = 1.0
        /* <code> */
    }

С возможной потерей данных можно автоматически привести: 
- `int` к `float` (соответствено, `char`, `byte` и `short` к `float`);
- `long` к `float`;
- `long` к `double`;

[`DataTypesDemo.java`][DataTypes]

    typesCastDemo() {
        /* <code> */
        intVal = 1_234_567_890;
        longVal = 123_456_789_000L;
        float floatVal2 = intVal, floatVal1 = longVal;
        double doubleVal2 = longVal;
        System.out.println(intVal + " to float = " + floatVal2); // 1234567890 to float = 1.23456794E9
        System.out.println(longVal + " to float = " + floatVal1); // 123456789000 to float = 1.23456791E11
        System.out.println(longVal + " to double = " + doubleVal2); //123456789000 to double = 1.23456789E11
        /* <code> */
    }    

#### 6.2. Повышение типа при математических операциях

Если в процессе вычисления [арифметической операции](Operators.md#1--) один из операндов имеет "больший" тип, чем 
второй, результат вычисления автоматически "повышается": принимает "больший" тип данных:
- операции с `byte` и `short` - всегда в результате дают тип `int`;
- операция с `int` и `long` - в результате даст тип `long`;
- операция с `int` и `float` - в результате даст тип `float`;
- операция с `long` и `float` - в результате даст тип `double`;
- операция с `int` (или `long`, или `float`) и `double` - в результате даст тип `double`. 

#### 6.3. Явное приведение типов

Явное приведение типов применяется, когда необходимо переменную б*о*льшего диапазона поместить в переменную м*е*ньшего 
диапазона.  
Например, если мы уверены, что в переменной типа `int` хранится число от -10 до 10, то вполне допустимо привести его к 
типу `byte`.

Для явного приведения типов необходимо значение (или переменную, выражение, результат вызова метода) предварить 
необходимым типом данных в скобках:

    long longVal = 123L;
    int intVal = (int) longVal;

Явно привести можно любой численный тип (целый и дробный) - к другому, "меньшему" численному типу (тоже целому или 
дробному).  
Дробные числа приводятся к целым путём отбрасывания дробной части. Округления не производится.

[`DataTypesDemo.java`][DataTypes]

    typesCastDemo() {
        /* <code> */
        doubleVal = 3.9485;
        longVal = (long) doubleVal;
        System.out.println(doubleVal + " to long = " + longVal); // 3.9485 to long = 3
        /* <code> */
    }

Тип `char` фактически является целочисленным, соответственно, приводится как целочисленный тип со значением равным коду 
Unicode-символа.

Тип `boolean` численным **не является**. Никакие другие примитивные типы не приводятся к `boolean`, и наоброт `boolean` 
не приводится ни к каким другим примитивным типам.

Явное приведение типов нужно использовать аккуратно: если *приводимое* значение будет больше диапазона *целевого*
контейнера (типа данных), результат будет **непредсказуемым** (зависит от реализации JVM и не только).

[`DataTypesDemo.java`][DataTypes]

    typesCastDemo() {
        /* <code> */
        longVal = 4_294_968_407L;
        intVal = (int) longVal;
        System.out.println(longVal + " to int = " + intVal); // 4294968407 to int = 1111
        /* <code> */
    }

<!--  ------------------------------  -->
[DataTypes]: DataTypesDemo.java
