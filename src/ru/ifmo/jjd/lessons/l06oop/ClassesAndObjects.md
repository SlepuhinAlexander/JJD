## Объекты и классы

### Введение 

В языке Java всё является объектом. (За исключением примитивных типов данных).  
Объект является логической единицей программы, объединяющей в себе некоторые данные и способы работы с этими данными.

Объект всегда строится на основе заранее описанного класса, который является типом данных для этого объекта. Так же 
говорят, что объект является экземпляром класса. Другими словами, класс описывает из чего состоит каждый объект этого 
класса (этого типа данных), и какое поведение есть у каждого объекта этого класса (этого типа данных).

Класс (и соответственно, объект этого класса) содержит **свойства** (так же могут называться _поля_,  _атрибуты_, 
_переменные экземпляра_), в которых хранятся **данные** класса, и **методы**, описывающие **поведение** класса (то, как 
класс работает со своими данными).

Класс является логически ограниченной, определённой сферой ответственности и заключает в себя ограниченный набор данных 
и действий с ними.

### Задача

Для примера, построим необходимые классы для работы библиотеки:  
Библиотека предназначена для хранения набора книг и выдачи их читателям.  
При этом каждая книга имеет:
- название;
- заданное количество страниц;
- одного автора (состоящего из имени и фамилии) _(ограничим число авторов до одного для простоты)_;
- признак можно ли её брать домой;
- признак доступна ли в данный момент для выдачи.

В библиотеке можно:
- добавлять книги в хранилище библиотеке, по одной или несколько сразу;
- взять книгу (указав название книги) для чтения;
    - при этом можно взять книгу домой или взять её для чтения в библиотеке;
- возвращать взятую книгу обратно в библиотеку.

### Соглашение по именованию классов

Технически, для именования классов, как и для именования файлов в операционной системе, возможно использование 
почти любых Unicode символов (кроме запрещённых, зарезервированных операционной системой). Имя класса должно 
_начинаться_ с латинской буквы или знаков `_` или `$`. Кроме того, имя класса не должно совпадать с зарезервированным в 
Java ключевым словом.  
Имя класса должно быть уникально в пределах содержащего его пакета (равносильно именам файлов в одной родительской 
директории). При этом полное имя класса должно быть глобально уникально. 

Соглашение по именованию предписывает использовать в именах классов только символы латинского алфавита и цифры. 
Начинать имя класса предписывается с заглавной латинской буквы. Имя класса, состоящее из нескольких слов, 
предписывается указывать слитно, без разделителей, каждое из слов начинать с заглавной буквы. Например, 
`ClassesAndObjectsDemo`. Также этот стиль именования называют CamelCase.
Имя класса должно отражать смысл его содержимого.  

Для библиотеки мы будем использовать классы `Library`, `Book`, `Author` для хранения данных и работы с ними. И в классе 
`Main` (с точкой входа в программу) будем создавать и использовать объекты этих классов.

### Объявление класса

Для создания класса необходимо в файле исходного кода `<ИмяФайла>.java` указать ключевое слово `class` и имя класса.
Имя пакета, в котором будет находиться класс должно быть указано в начале файла, в котором создаётся класс, в виде 
инструкции `package`. Например,

    package ru.ifmo.jjd.lessons.l06oop;
    
    public class Library {}

Объявление класса может предваряться модифиактором доступа (см. ниже).  
Класс с модификатором доступа `public` в пределах `.java` файла может быть только один. При этом имя файла 
**обязательно** должно совпадать с именем этого публичного класса.  
Технически, Java разрешает использовать другие, не-`public`, классы в том же файле, но в большинстве огранизаций 
принят к использованию принцип: на каждый класс - отдельный файл. (За исключеением вложенных / внутренних классов). 
<!--(см. [[Внутренние классы]]())-->

Все содержимое класса располагается в пределах фигурных скобок, следующих за объявлением класса

    package ru.ifmo.jjd.lessons.l06oop;
    
    public class Library {
        /*
         * <Весь исходный код класса Library>
         */
    }

### Создание объектов класса

Для создания объекта необходимо:
- указать тип данных (имя класса); с учётом, возможно, необходимого импорта пакета;
- указать имя переменной-объекта;
- поставить оператор присваивания;
- поставить ключевое слово `new`, указывающее что создаётся новый объект;
- и использовать конструктор класса, котрый, собственно и создаёт объект.   
    Конструктор класса вызывается из имени класса и переданных в конструктор атрибутов в скобках.  
    По умолчанию, конструктор не имеет атрибутов.


    // Main.java 
    package ru.ifmo.jjd.lessons.l06oop;
    
    public class Main {
        public static void main(String[] args) {
            Author author1 = new Author();
        }
    }
    
Здесь создаётся объект класса `Author` с именем `author1`.

    // Main.java
    /*
     * <code> 
     */
    Author author2 = new Author();

Создан второй объект класса `Author` с именем `author2`.  
Объект `author2` никак не связан с объектом `author1`, они независимы и самодостаточны.
Их объединяет только общий тип данных. А значит, то, какие у них есть свойства (поля) и какие методы они могут 
выполнять.

### Описание свойств класса

Пока что класс `Author` не имеет никаких свойств и методов. Соответственно, и объекты `author1` и `author2` не имеют 
никаких свойств и методов.

Чтобы задать свойство класса необходимо в описании класса указать тип данных и имя свойства. Требования к имени 
свойства такие же как и к локальным переменным: только латиница, начиная со строчной буквы, имя из нескольких слов 
задаётся слитно, в camelCase нотации.  
Таким образом, определение свойства класса аналогично объявлению обычной локальной переменной. Поэтому иногда в 
литературе свойства класса называют **переменной экземпляра** класса.

    // Author.java
    package ru.ifmo.jjd.lessons.l06oop;
    
    public class Author {
        String name;
    }

### Обращение к свойствам объекта <a name="calling-field"></a>

Далее для того чтобы обратиться к этому свойству необходимо указать имя объекта, затем через точку указать имя свойства 
объекта.

    // Main.java
    /*
     * <code> 
     */
    Author author1 = new Author();
    author1.name = "Брюс";
    System.out.println(author1.name); // Брюс
    
    Author author2 = new Author();
    author2.name = "Роберт";
    System.out.println(author2.name); // Роберт
    
Таким образом можно задавать значения свойства (или переопределять уже заданное) и считывать эти значения.

### Модификаторы доступа

Модификаторы доступа - это дополнительные инструкции, указывающие копмилятру на ограничение доступа к свойству или 
методу класса (и соответственно, всех объектов этого класса).  
Модификатор доступа указывается в описании класса перед объявлением свойства или метода.  
В Java есть следующие 4 модификатора доступа: 

- _**public**_ - разрешает доступ к свойству / методу везде, из любого класса, из любого пакета.  
    Самый широкий доступ.
- _**protected**_ - разрешает доступ к свойству / методу данного класса только для классов-наследников этого класса, 
    **и** для всех классов в том же пакете; запрещает доступ всем остальным классам.
- _(пусто, ничего не указано)_ - доступ по умолчанию; также называется `package-default`; разрешает доступ к свойству / 
    методу класса для всех классов в том же пакете; запрещает доступ всем остальным классам. В отличие от модификатора 
    `protected` если класс-наследник находится в другом пакете по сравнению со своим родительским классом, то 
    класс-наследник _не будет_ иметь доступа к свойству / методу родительского класса.
- _**private**_ - разрешает доступ к свойству / только в этом же классе; запрещает доступ всем остальным классам. Самый 
    ограниченный доступ.
    
О наследовании классов см. [[Наследование]](../l07inheritance/README.md).

### Геттеры и сеттеры

Логика работы программы часто может ограничивать то, какие значения допустимо сохранять в свойстве класса, а какие - 
нет.  
 
Для того чтобы оградить свойство класса от нежелательного изменения (присвоения ему нежелательных значений); для того 
чтобы провести некоторые проверки или преобразования данных перед тем как их присвоить свойству класса применяются 
ограничивающие модификаторы доступа (см. выше).

Также ограничивающие модификаторы доступа могут использоваться для того чтобы свойство класса, не предназначенное для 
внешнего использования, вообще скрыть от внешнего пользователя класса.

    // Author.java
    /*
     * <code> 
     */
    private String name;

Теперь, после установки модификатора доступа `private` свойство `name` стало доступно только в пределах класса 
`Author`, а в других классах оно не видно. Инструкции

    // Main.java
    /*
     * <code> 
     */
    author1.name = "Брюс";
    System.out.println(author1.name);
    author2.name = "Роберт";
    System.out.println(author2.name);

перестали компилироваться, т.к. нет доступа к свойству `name` ни на чтение, ни на запись.

Если свойство класса предполагается использовать извне, но при этом нужно защитить свойство от нежелательных данных, 
применяется следующая методика:
- само свойство класса закрывается от прямого доступа модификатором `private`
- в классе создаётся два метода, **геттер** и **сеттер**, для которых устанавливаются менее строгие ограничения доступа 
    (чаще всего просто `public`), и которые безопасно работают с данным свойством уже внутри класса.
- метод-сеттер в качестве параметра принимает значение, которое внешний пользователь желает установить свойству; 
    выполняет необходимые проверки / преобразования, и, если переданное (преобразованное) значение удовлетворительно, 
    присваивает его свойству объекта.
- метод-геттер, как правило, не имеет параметров, а считывает текущее значение свойства объекта и в результате своей 
    работы возврашает его вызывающему коду.
    
Согласно соглашению по именованию, методы-геттеры принято называть `get<ИмяСвойства>`, а сеттеры -- `set<ИмяСвойства>`.

    // Author.java
    private String name;
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
    
### Описание методов класса

Рассмотрим подробнее описание метода класса на примере сеттера

    public void setName(String name) {
        this.name = name;
    }

Описание метода состоит из:
- модификатора доступа к методу;  
    Здесь, `public` - это модификатор доступа, который означает, что к данному методу можно обращаться из любого 
    контекста (из любого класса / любого пакета).  
    Напомним, что если модификатор доступа не указан конкретно, он всё равно есть: используется `package-default` 
    доступ.
- типа данных, которые метод возвращает;  
    Здесь, типа данных `void` означает, что метод не возвращает ничего.
- имени метода;  
    К именам методов предъявляются те же требования, что и к именам свойств, и именам локальных переменных: 
    используется camelCase нотация. 
- списка аргументов метода;  
    Уазывается в скобках. Может быть пустой. 
    Состоит из пар: ТипДанныхАргумента и имяАргумента.
    Аргументы метода, по сути, являются локальными переменными этого метода.
- тела метода;  
    Следует за объявлением метода, содержится в фигурных скобках.  
    Тело метода это весь код, который выполняется во время выполнения метода.

Имя метода и список его аргументов (указанные типы данных аргументов и их порядок - важны!) все вместе называются 
**сигнатурой** метода. Сигнатура метода в пределах класса должна быть уникальна.  
Другими словами, разрешается в одном классе иметь несколько методов с одинаковыми именами но разными наборами 
аргументов. Такая контрукция называется **перегрузкой** метода, а такой метод, соответственно, называется 
**перегруженным**. Например:

    public void doSomething() {/* <тело метода> */}
    public void doSomething(int i) {/* <тело метода> */}
    public void doSomething(String s) {/* <тело метода> */}
    public void doSomething(int i, String s) {/* <тело метода> */}
    public void doSomething(String s, int i) {/* <тело метода> */}

это корректно объявленные 5 вариантов перегрузки метода `doSomething()`.

### Ключевое слово `this`

Вернёмся к сеттеру `setName()`. Добавим в него проверку, что имя автора должно быть не короче 2 символов. В противном 
случае, значение свойства name оставим неизменным.

    public void setName(String name) {
        if (name.length() >= 2) {
            this.name = name;
        }
    }

Отдельно нужно пояснить ключевое слово `this`. Слово `this` является _ссылкой на текущий объект_ класса, который 
вызывает данный метод.  
В если не использовать ссылку `this` в методе `setName()`, то возникнет конфликт имён: у нас и свойство класса имеет 
имя `name`, и аргумент метода тоже имеет имя `name`. В инструкции 

    name = name;

нет однозначного понимания, какая из двух сущностей должна использоваться слева и справа от оператора присваивания.  
_(На самом деле компилятор в этом случае оба раза использует аргумент метода, и, соответственно, метод не сделает 
ничего)_.  
Есть два варианта как избавиться от этой неоднозначности. Можно изменить имя аргумента метода, оно может быть любым 
допустимым: 

    public void setName(String n) {
        if (n.length() >= 2) {
            name = n;
        }
    }

Тогда компилятор "понимает", что _свойству_ `name` вывзавшего объекта нужно установить значение переданное в 
_аргументе_ `n`.  
Но конкретно в сеттерах принято использовать имя аргумента равное имени свойства, и в теле метода использовать ссылку 
`this`:

    this.name = name;

В таком случае, компилятору явно указано, что слева от оператора присваивания стоит _свойство_ `name` вывзавшего 
объекта, а справа - аргумент `name` этого метода.   

### Методы с возвращаемым значением и ключевое слово `return`

Теперь рассмотрим подробнее геттер `getName()`.

    public String getName() {
        return name;
    }

Метод-сеттер, когда его вызовут, выполнит свой код (тело метода) и на этом закончит. Выполнение программы вернётся к 
той строке, где был вызван сеттер.  
Метод-геттер устроен иначе. Он предназначен для того чтобы считать значение свойства и **передать** его вызвавшему 
объекту. Для этого метод должен "уметь" возвращать результат своей работы.  
Если метод имеет возвращаемое значение, то это самое значение полученное от выполненного метода, вызвавший код может 
присвоить какой-то переменной, использовать в выражении, или передать дальше в качестве аргумента какого-то ещё метода. 
  
Чтобы описать, что метод, в результате своей работы возвращает значение, нужно:
- в объявлении метода указать тип данных для возвращаемого значения;
- в теле метода использовать инструкцию `return` с указанием возвращаемого значения.

Ключевое слово `return` указывает какое именно значение должен вернуть метод в результате своей работы.  
Это может быть явно заданное значение, значение какой-то переменной, результат выражения, или результат вызова метода.  
Возвращаемое значение в `return` должно быть совместимо с указанным типом возвращаемого значения, иначе будет ошибка 
компиляции или времени выполнения.  
Если метод ничего не возвращает, то в объявлении метода указывается тип возвращаемого значения void.

Также инструкция `return` **прекращает** выполнение метода. Никакой код код после return выполняться не будет.  
В связи с этим инструкция `return` может использоваться для досрочного прерывания выполнения метода. Например, если 
выполнено какое-то условие и дальнейшее выполнение данной ветки кода больше не нужно.  
По этой же причине прерывания выполнения метода, если метод должен возвращать какое-то значение, и в теле метода есть 
ветвления (инструкции `if-else`, `switch`), то _все_ возможные ветви кода должны в конечном счёте дойти до инструкции 
`return`, иначе будет ошибка компиляции.
 
В методах с типом возвращаемого значения `void` инструкцию `return` также можно использовать для досрочного прерывания 
работы метода. Но поскольку от метода не ожидается возвращение значения, необходимо использовать инструкицю `return` 
без какого-либо значения:

    if (isEverythigOK) {
        return;
    }

### Обращение к методам объекта <a name="calling-method"></a>

Аналогично обращениям к свойствам объекта, для того чтобы обратиться к методу объекта необходимо указать имя объекта, 
затем через точку указать имя метода, и затем в скобках, через запятую, передать аргументы методу (если аргументов нет, 
то указываются пустые скобки).

    // Main.java
    /*
     * <code> 
     */
    Author author1 = new Author();
    author1.setName("Брюс");
    System.out.println(author1.getName()); // Брюс

    Author author2 = new Author();
    author2.setName("Роберт");
    String name = author2.getName();
    System.out.println(name); // Роберт
    
### Текстовое представление объекта

Добавим классу `Author` свойство `surname` и соответствующие геттер и сеттер.  
В описании класса принято придерживаться следующего порядка: сначала описываются свойства класса, затем его 
конструкторы (см. ниже), затем методы класса. Дальнейший порядок в каждой из этих структурных групп не важен.

    // Author.java
    private String name;
    private String surname;
    
    public void setName(String name) {/* <тело метода> */} 
    
    public String getName() {/* <тело метода> */}
    
    public void setSurname(String surname) {
        this.surname = surname;
    } 
    
    public String getSurname() {
        return surname;
    }
    
И зададим эти свойства нашим объектам:

    // Main.java
    /*
     * <code> 
     */
    author1.setSurname("Эккель");
    author2.setSurname("Мартин");
    
Попробуем теперь получить текстовое представление объекта.  
Для того чтобы преобразовать любой объект в строку, необходимо вызвать его метод `toString()`. Метод `toString()` 
существует в любом классе и, следовательно, может быть вызван у любого объекта.

    // Main.java
    /*
     * <code> 
     */
    String stringAutor1 = autor1.toString();
    System.out.println(stringAutor1);

В методах печати в консоль `print()`, `println()`, `printf()`, если аргументом им передать объект, - неявно вызывается 
метод `toSrting()` для приведения объекта к строке и в консоль печатается уже полученная строка.
Таким образом, инструкции

    // Main.java
    /*
     * <code> 
     */
    System.out.println(stringAutor1);
    System.out.println(autor1.toString());
    System.out.println(autor1);
    
делают одно и то же.
    
Если запустить программу, то печать в консоль выдаст не имя и фамилию автора1, как нам бы хотелось, а

    System.out.println(autor2); // ru.ifmo.jjd.lessons.l06oop.Author@3feba861

т.к. метод `toString()`, определённый по умолчанию, выдаёт полное имя класса объекта (полное имя пакета плюс имя 
класса) и хеш-код объекта в оперативной памяти.

Чтобы иметь возможность преобразовывать объекты нашего класса `Author` к строке, необходимо в классе `Author` 
**переопределить** метод `toString()`.  

    // Author.java
    /*
     * <code> 
     */
    @Override
    public String toString() {
        /* <Код для получения строки с данными объекта, например: > */
        return "Author{" +
                "name='" + name + '\'' +
                ", surname='" + surname + '\'' +
                '}';
    }

Аннотация `@Override` не обязательна. Она указывает компилятору и среде разработки, что метод `toString()`- 
переопределён.

Теперь, вызывая печать объектов типа `Author` в консоль, мы будем получать текстовое представление данных объекта:

    System.out.println(autor2); // Author{name='Роберт', surname='Мартин'}
    
### Значения свойств объектов по умолчанию

Перейдём теперь к классу `Book`. Согласно описанию, книга должна иметь: название, автора, количество страниц, признак 
можно ли брать её домой и признак доступна ли она для выдачи.

Название - имеет тип `String`; количество страниц - целочисленный тип `int`; переменные-признаки, поскольку они могут 
принимать значения только "да" и "нет", логично сделать типа `boolean`.  
Согласно соглашению об именовании свойства, имеющие булевский тип (а так же локальные переменные, и методы, 
возвращающие булевский тип) принято называть `is<Признак>`. Соответствующий геттер будет иметь имя равное имени 
свойства `is<Признак>`, а сеттер - `set<Признак>`.  
С автором книги интереснее: автор - это _объект_ типа `Author`. Таким образом, объект может в своём составе (в качестве 
своего свойства) содержать и другой объект. При этом уровни вложенности не ограничены.

    ru.ifmo.jjd.lessons.l06oop;
    
    public class Book {
        private String title;
        private int pageCount;
        private Author author;
        private boolean isForHome;
        private boolean isInLibrary;
    
        public String getTitle() { return title; }
    
        public void setTitle(String title) { this.title = title; }
    
        public int getPageCount() { return pageCount; }
    
        public void setPageCount(int pageCount) { this.pageCount = pageCount; }
    
        public Author getAuthor() { return author; }
    
        public void setAuthor(Author author) { this.author = author; }
    
        public boolean isForHome() { return isForHome; }
    
        public void setForHome(boolean forHome) { isForHome = forHome; }
    
        public boolean isInLibrary() { return isInLibrary; }
    
        public void setInLibrary(boolean inLibrary) { isInLibrary = inLibrary; }
    
        @Override
        public String toString() { return "Book{title='" + title + '\'' + ", pageCount=" + pageCount
                    + ", author=" + author + ", isForHome=" + isForHome + ", isInLibrary=" + isInLibrary + '}'; }
    }
   
Создадим книгу и напечатаем её в консоль:

    // Main.java
    /*
     * <code> 
     */
    Book book1 = new Book();
    System.out.println(book1);
    // Book{title='null', pageCount=0, author=null, isForHome=false, isInLibrary=false}
    
Несмотря на то, что созданной книге `book1` мы не устанавливали никаких значений свойств, можно видеть, что какие-то 
значения свойствам уже присвоены.  
В момент создания объекта всем его свойствам присваиваются **значения по умолчанию** (если не указано иное - см. ниже 
Конструкторы), в зависимости от типа данных:

- для целочисленных типов - `0`
- для чисел с плавающей точкой - `0.0`
- для булевских - `false`
- для всех ссылочных типов - `null`

### Пара слов о `null`

    // Book{title='null', pageCount=0, author=null, isForHome=false, isInLibrary=false}

Ключевое слово `null` означает пустую ссылку. Если значение ссылки (например, `author`) на объект - равно `null`, то 
значит ссылка `author` на самом деле не ссылается ни на какой объект.  
Если по такой ссылке попытаться обратиться к свойству или методу объекта, то программа не сможет выполниться (ей не к 
чему обратиться), выдаст ошибку времени исполнения `java.lang.NullPointerException` и прервёт выполнение.

При работе с объектами (ссылочными типами данных) нужно быть аккуратными и держать в уме, что объект, в худшем случае, 
может оказаться `null`-ом и эти исключительные ситуации нужно отлавливать и обрабатывать.

<!-- Об обработке ошибок см. [[Обработка ошибок]]() -->


### Конструкторы

Конструктор это та часть класса, которая описывает _как именно_ должны создаваться объекты (экземпляры) этого класса.  
В некотором смысле, можно сказать, что конструктор - это метод класса, который выполняется, когда создаётся объект 
этого класса. 

Для новых классов компилятор Java всегда неявно создаёт конструктор следующего вида:

    public <ИмяКласса>() { }
    
Например, в классе `Book`, несмотря на то, что явным образом там этого не прописано, неявно присутствует конструктор

    // Book.java
    /*
     * <code> 
     */ 
    public Book() { }
    
с пустым телом.  
Именно поэтому для создания объекта `book1` мы сразу могли использовать конструкцию `new Book()`

    // Main.java
    /*
     * <code> 
     */
    Book book1 = new Book();
    
И именно поскольку тело у конструктора, созданного по умолчанию, - пустое, то никакого дополнительного кода не 
выполнялось, и значения свойствам объекта были установлены по умолчаниию.

Мы можем явно дописать этот же конструктор 

    public Book() { }

в тело класса `Book` - ничего не изменится.

Чтобы самостоятельно определить, как именно должны создаваться объекты (экземпляры) класса, необходимо в описании 
класса добавить свой, новый конструктор, и затем использовать его при создании объектов.

### Объявление конструктора

    // Book.java
    /*
     * <code> 
     */
    public Book(String title) {
        setTitle(title);
    }

Объявление конструктора похоже на объявление метода состоит из:
- модификатора доступа;  
    Как правило, используется `public`, если только не нужно скрыть возможность создания объектов класса.
- имени конструктора;  
    Имя конструктора **всегда** совпадает с именем класса. С учётом регистра. 
- списка аргументов конструктора;  
    Уазывается в скобках. Может быть пустой. 
    Состоит из пар: ТипДанныхАргумента и имяАргумента.  
    Аргументы конструктора, по сути, являются локальными переменными этого конструктора.
- тела конструктора;  
    Следует за объявлением конструктора, содержится в фигурных скобках.  
    Тело метода это весь конструктора, который выполняется во время выполнения конструктора, т.е. во время создания 
    объекта.
    
В отличие от методов класса, конструтор не имеет возвращаемого значения (никакого, даже `void`), и всегда имеет имя 
равное имени класса.

Тело конструктора может содержать что угодно. Присвоение значений свойствам, вызов методов, создание других объектов 
и т.д.

### Перегрузка конструктора

Так же как и методы, конструкторы можно перегружать. Т.е. создавать несколько вариантов конструкторов с различными 
наборами аргументов. _(Напомним, что уникальными должны быть типы данных аргументов и их порядок следования)._

    public Book() { }
    
    public Book(String title) {
        setTitle(title);
    }
    
    public Book(String title, int pageCount) {
        this.title = title;
        this.pageCount = pageCount;
    }

Зачастую, конструкторы могут быть использованы для присвоения начальных значений свойствам объекта, согласно переданным 
аргументам; конструктор без аргументов может устанавливать начальные значения всем свойствам объекта.  
Но на этом использование конструкторов не ограничивается, тело конструктора может содержать любой код.
    
**Важно**, что если в классе явно описан хотя бы один конструктор (например, с аргументами), то конструктор по 
умолчанию 

    public <ИмяКласса>() { }

становится более недоступен, его использовать нельзя.  
Если же при этом классу необходим конструктор без аргументов, его необходимо явно прописать в классе. _(Возможно, с 
непустым телом)_  
Считается, что если создатель класса самостоятельно использует конструкторы, то он сам позаботится о создании пустого 
конструктора (конструктора без аргументов) 

### Вызов конструкторов

Вызов конструкторов похож на вызов методов в том смысле, что указывается имя конструктора (равное имени класса) и за 
ним в скобках передаётся список аргументов конструктора (если нужно). Предваряется это, как сказано в самом начале 
занятия, ключевым словом `new`, указывающим, что создаётся новый объект.

    // Main.java
    /*
     * <code> 
     */
    Book book0 = new Book();
    System.out.println(book0);
    // Book{title='null', pageCount=0, author=null, isForHome=false, isInLibrary=false}
    
    Book book1 = new Book("Философия Java");
    System.out.println(book1);
    // Book{title='Философия Java', pageCount=0, author=null, isForHome=false, isInLibrary=false}
    
    Book book2 = new Book("Чистый код", 500);
    System.out.println(book2);
    // Book{title='Чистый код', pageCount=500, author=null, isForHome=false, isInLibrary=false}
    
В первом случае использовался конструктор без аргументов (и с пустым телом), поэтому все значения свойств объекта 
`book1` выставлены по умолчанию.  
Во втором случае, в конструктор было передано значение, предназначенное для свойства `title`, и оно было так 
установлено в созданном объекте `book1`.
В последнем случае использовался конструктор с двумя аргументами, который установил значения свойствам `title` и 
`pageCount` объекта `book2`.

Используя имеющиеся сеттеры можно до-заполнять оставшиеся свойства объектов:

    // Main.java
    /*
     * <code> 
     */
    book1.setPageCount(1350);
    book1.setAuthor(author1);
    book1.setForHome(true);
    System.out.println(book1);
    // Book{title='Философия Java', pageCount=1350, author=Author{name='Брюс', surname='Эккель'}, isForHome=true,
    // isInLibrary=false}
    
    book2.setAuthor(author2);
    System.out.println(book2);
    // Book{title='Чистый код', pageCount=500, author=Author{name='Роберт', surname='Мартин'}, isForHome=false,
    // isInLibrary=false}

### Обращение к свойствам или методам вложенных объектов

Допустим, мы хотим получить имя автора книги `book1`. Поскольку имя сокрыто внутри объекта-автора книги, то сначала 
нужно получить из книги - автора, а затем из автора - имя. Обе операции выполняюся как обращение к объекту по его 
ссылке, плюс точка, плюс вызов свойства или метода. Поэтому:

    // Main.java
    /*
     * <code> 
     */
    System.out.println(book1.getAuthor().getName()); // Брюс 
    
У объекта `book1` вызван метод `getAuthor()`, который вернул значение свойства `book1.author`, которое в данный момент 
равно `author1`. Затем от результата (от `book1.author`) вызван метод `getName()`, который вернул значение свойства 
`book1.author.name`, равное "Брюс", которое затем было передано в метод печати в консоль `println()`. 

### Создание новых методов

Перейдём к созданию библиотеки - классу `Library`.

    // Library.java
    package ru.ifmo.jjd.lessons.l06oop;

    public class Library {
        private String name = "Библиотека";

        public String getName() {
            return name;
        }
    }

Здесь свойству `name` сразу присвоено значение "Библиотека". Это ещё один способ устанавливать значения свойства 
объекта по умолчанию.  
Поскольку у свойства `name` задано начальное значение, установлен `private` доступ, задан геттер, но не существует 
сеттера, это значение невозможно будет изменить. То есть все объекты класса `Library` будут иметь название "Библиотека".

Согласно требованиям, программа должна уметь добавлять книги в библиотеку. Создадим хранилище для книг `books` и новый 
метод добавления книги в хранилище `addBook()`:

    // Library.java
    /*
     * <code> 
     */
    private Book[] books = new Book[5];
    /*
     * <code> 
     */
    
    public void addBook(Book newBook) {
        
        for (int i = 0; i < books.length; i++) {
            if (books[i] == null) {
                books[i] = newBook;
                newBook.setInLibrary(true);
                break;
            }
        }
    }
    
В качестве имени метода принято указывать глагол или фразу, описывающую то метод делает.  
Метод `addBook()` с одним аргументом `newBook` типа `Book` добавляет книгу `newBook` в хранилище. Если может: если 
книга настоящая и если в хранилище есть место.   
Добавленной в хранилище книге устанавливается признак, что она есть в библиотеке.  

Также согласно требованиям в библиотеке должно быть можно запросить книгу по названию и взять её для чтения домой. 
Добавим такой метод `getHome()`:
    
    // Library.java
    /*
     * <code> 
     */ 
    public Book getHome(String title) {
        if (title == null || "".equals(title)) {
            return null;
        }
        for (Book book : books) {
            if (book != null && title.equals(book.getTitle()) &&
                    book.isInLibrary() && book.isForHome()) {
                book.setInLibrary(false);
                return book;
            }
        }
        return null;
    }
    
Если запрос не корректен (переданное название книги является пустой ссылкой или пустой строкой) не делаем ничего, 
возвращаем пустую ссылку, прерываем работу метода.  
Иначе, среди всех существующих книг ищем такую, которая по названию совпадает с запросом, и при этом она есть в наличии 
и её можно выдавать на дом.  
Если таковая нашлась, помечаем, что она выдана (что её больше нет в библиотеке) и возвращаем её тому, кто запросил.  
Если же такая книга не найдётся, снова возвращаем пустую ссылку как неудачное выполнение метода.

Запросивший книгу код, проверкой на `null` результата метода `getHome()` может удостовериться, прошёл ли запрос книги 
удачно или нет, и в зависимости от этого действовать дальше по своему усмотрению.

### Методы с переменным количеством аргументов

Помимо прочего, согласно требованиям, в библиотеку должно быть можно добавить сразу несолько книг одним запросом.
Можно было бы написать несколько перегрузок для метода `addBook()` с 2, 3, 4 и т.д. аргументами типа `Book`, но, 
во-первых в требованиях нет ограничения на количество книг за раз, т.е. невозможно предугадать сколько таких методов 
потребуется, а во-вторых такой подход неэффективен.   
В языке Java есть механизм, котрый позволяет работать с изменяющимся, заранее неизвестным количеством аргументов у 
метода. Такие методы называются методами с переменным количеством аргументов.

Для объявления такого метода, нужно в списке его аргументов, после типа данных указать многоточие. Это будет означать, 
что данный аргумент может применятся методом в любых количествах (но не менее 1). 
_(На самом деле максимум количества аргументов ограничен максимальным размером массива в JVM)_.

    // Library.java
    /*
     * <code>
     */
    public void addBook(Book... newBooks) {
        for (Book book : newBooks) {
            addBook(book);
        }
    }

Во время выполнения метода с переменным количеством аргументов все эти переданные аргументы собираются в массив и 
используются внутри метода как массив. Т.е. `newBooks` для тела метода это уже обычный массив с типом хранимых данных 
`Book` и фиксированной (теперь уже известной) длиной.  
  
Поскольку сохранять по одной книге, используя все проверки, мы уже умеем методом `addBook()` с одним аргументом, то 
задачу добавления массива книг можно делегировать этому методу, просто передавая в него все книги из массива `newBooks` 
по очереди.

Для использования метода с переменным количеством аргументов, нужно передать ему в правильном порядке все фиксированные 
аргументы (в `addBook()` таких нет), а затем, так же продолжая список аргументов через запятую, передать в метод не 
менее одного аргумента нужного типа для аргумента переменной длины (в `addBook()` - типа `Book`).

    // Main.java
    /*
     * <code> 
     */
    Library library = new Library();
    library.addBook(book0, book1);
    library.addBook(book0, book1, book2);
    library.addBook(book0, book1, book2, new Book(), new Book("HeadFirst Java"));
    
В качестве объектов в метод можно передавать, конечно, не только ссылки на уже имеющиеся объекты, но и результат 
работы конструкторов (т.е. создать объект и без присвоения его переменной - сразу передать в метод), и результат работы 
метода (например геттера).

В связи с тем, что при вызове метода строго необходимо соблюдать последовательность аргументов, для аргумента переменной 
длины накладываются существенные ограничения:
- такой аргумент переменной длины в списке аргументов метода может быть только один;  
    Иначе невозможно было бы отличить, где закончился один список аргументов этого типа, - и начался второй.
- аргумент переменной длины в списке аргументов должен идти последним.  
    Иначе, снова, невозможно было бы отличить, где закончился список аргументов для аргумента переменной длины, - и 
    начались фиксированные аргументы,