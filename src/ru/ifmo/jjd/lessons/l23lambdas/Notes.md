## Функциональные интерфейсы и лямбда-выражения

Лямбда-выражение - это реализация абстрактного метода без создания класса, реализующего абстрактный метод.

Интерфейс должен быть (существовать) и абстрактный метод в нём должен быть задан.
Чтобы можно было использовать лямбду, у интерфейса должен быть только один абстрактный метод.
(и любое количество default методов).

Интерфейс, имеющий только один абстрактный метод называется **функциональным** интерфейсом.
Ограничений на метод нет: может возвращать void, может иметь любые аргументы, и т.д.

Функциональные интерфейсы стоит помечать аннотациями `@FunctionalInterface`

[LambdasDemo](LambdasDemo.java)

## Правила работы с синтаксисом лямбда-выражения

Правила работы с аргументами лямбда-выражения
- Количество аргументов в скобках, и в методе должно совпадать.
- Имена аргументов могут быть произвольные (не обязаны совпадать с именами аргументов в декларации метода в
     интерфейсе)
- Если у метода только один аргумент, заключать аргумент в () не обязательно.
- В остальных случаях скобки () должны быть. В том числе при нуле аргументов.
- Типы данных для аргументов можно не указывать, их типы данных берутся из контекста метода интерфейса.

После объявления аргументов лямбды следует `->`. Она должна быть всегда

Правила работы с телом лямбды:
- Если реализация метода состоит из одной инструкции и предполагается возвращать значение, то `{}` указывать не 
    нужно, `return` будет сделан по умолчанию.   
    Запись `(a,b) -> a + b;` равносильна записи `(a,b) -> {return a + b};`
- Если инструкций больше чем одна, то {} использовать обязательно.
     - в этом случае return по умолчанию - уже отсутствует; если метод должен возвращать значение - его
         нужно явно прописать в теле метода.
         
### Готовые функциональные интерфейсы

Помимо синтаксиса лямбд, в Java API есть множество готовых функциональных интерфейсов.

[FunctionalInterfacesDemo](FunctionalInterfacesDemo.java)

### Лямбды в коллекциях

[LambdasInCollectionsDemo](LambdasInCollectionsDemo.java)

Сам компаратор является функциональным интерфейсом.
Значит для написания реализации метода `compare` можно не создавать класс, а воспользоваться лямбда-синтаксисом.