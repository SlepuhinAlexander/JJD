## Сериализация

Для сохранения / передачи текущего состояния объектов программы необходимо иметь возможность преобразовать объект в 
последовательность байт.
А затем, получив эти байты из потока - восстановить объект.

**Сериализация** - это процесс преобразования объекта в последовательность байт.
**Десериализация** - это процесс обратного преобразования, из последовательности в объект. 

Сериализация используется для сохранения состояния объектов, например, для записи в файл.

Для сериализации объекта, каждое его свойство в отдельности, преобразуется в последовательность байт.
При десериализации, наоборот, каждое свойство последовательно восстанавливается.

Для работы десериализации в классе восстанавливаемого объекта обязательно должен быть конструктор без параметров.

Для того, чтобы можно было передавать объекты в поток, классы этих объектов должны реализовывать интерфейс 
`java.io.Serializable` или `java.io.Externalizable`.
`Serializable` по умолчанию сериализует **все** свойства объекта, но можно указать что исключить.
`Externalizable` по умолчанию не сериализует никакие свойства объекта, но можно указать что конкретно сериализовать и 
как.

    public class Pupil extends Human implements LearnAble, Serializable
   
Если дочерний класс реализует интерфейс `Serializable`, то сериализованы будут только поля дочернего класса. 
Родительские поля сериализованы не будут.
Чтобы сериализовывать всё, реализовывать интерфейс `Serializable` нужно у родителя.

Классы для вложенных объектов должны быть сериализуемыми.

Чтобы исключить свойство из сериализации (при `Serializable` интерфейсе), нужно его пометить ключевым словом 
`transient`. Такие свойства сериализованы не будут. 

Большинство классов `java.***` - сериализуемы.
Коллекции, Мапы - тоже сериализуемы.

Когда класс создаётся - он создаётся с какой-то версией.
При сериализации объекта версия класса тоже сохраняется.
При десериализации сверяются версии сериализованного класса и текущая версия класса. Если они не равны.
Если после сериализации версия класса стала выше, то десериализация не отработает - выбросит исключение.

Чтобы этого избежать, нужно указать в классе его `serialVersionUID`

    private static final long serialVersionUID = 1L
    
Тогда для этого класса его версия всегда будет равно указанной, и не будет ошибки десериализации.  

Но при этом возможны уже потери сохранённых данных: если структура класса изменилась по сравнению

----

Напишем две программки, которые будут обмениваться сообщениями.
Сделаем разделение на серверную и клиентскую программы.

Клиентская программа должна сформировать сообщение, и оправить его серверной.
Серверная программа должна получить сообщение и вернуть какой-то ответ.

Данные будем передавать через установленное подключение (сокет) по TCP/UDP протоколу.

Серверная программа будет иметь IP адрес в сети и порт, который она слушает.
Клиентская програмаа, соответственно, для подключения должна знать IP сервера и порт для подключения.

Когда будет установлено подключение (по Socket соединению), из него можно будет получить входящий и исходящий потоки.  