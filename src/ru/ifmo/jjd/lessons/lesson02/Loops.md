## Циклы

**Циклы** - это повторящиеся однотипные действия, которые выполняются до тех пор пока истинно какое-то условие.  
Каждое повторение цикла называется **итерацией** цикла.

В Java есть два типа циклов, каждый из которых имеет по две формы:
- Цикл `while`:
    - с предусловием (так же может встречаться название `while-do` по аналогии с другими языками);
    - с постусловием (он же `do-while`);
- Цикл `for`:
    - обычный (он же `fori`);
    - улучшенный (он же `for each` или `foreach`)

### Цикл `while` с предусловием

Цикл `while` имеет синтаксис:

    while(условие) {
        // тело цикла
    }
    // код после цикла
    
Смысл цикла `while`: пока выполняется `условие`, выполнять `тело цикла`; как только `условие` перестало выполняться - 
перейти к `коду после цикла`.  

Проверяемое `условие` всегда должно иметь тип `boolean` (или `Boolean`).  

Выполнение цикла: 
- Перед входом в цикл проверяется `условие`. `Условие` проверяется перед *каждой* итерацией цикла. Если `условие` 
    истинно, выполняется `тело цикла`.
- После выполнения `тела цикла` (текущей итерации) выполнение программы возвращается назад к проверке `условия`.
- Если `условие` по-прежнему верно, то начинается следующая итерация цикла и `тело цикла` снова выполняется.
- Если `условие` ложно, то исполнение программы переходит к `коду после цикла`.
- Так продолжается до тех пор пока `условие` истинно.

Ситуация, когда следующая итерация цикла не должна выполняться также называется **выходом из цикла**.

Если `условие` всегда истинно (например, было истинным и не изменяется внутри `тела цикла`), то цикл будет
продолжаться *бесконечно*.  
Если `условие` изначально было ложным, `тело цикла` не выполнится *ни разу*.

Пример:  
Пользователь вводит целое число с клавиатуры. Необходимо вывести квадрат этого числа.   
Программа прерывает работу, если пользователь ввёл ноль.

    // LoopsDemo.java
    // whileDemo()
    /*
     * <code> 
     */
    Scanner scanner = new Scanner(System.in);
    int num;
    while (true) {
        System.out.print("Введите число: ");
        num = scanner.nextInt();
        if (num == 0) {
            System.out.println("Выход из программы");
            break;
        }
        System.out.println("Квадрат вашего числа равен " + num * num);
    }
    /*
     * Введите число: 11
     * Квадрат вашего числа равен 121
     * Введите число: 0
     * Выход из программы
     * */

Здесь используется бесконечный цикл (`while(true)`) с прерыванием при выполнении некоторого условия.  
Директива `break;` **прерывает** в ыполнение цилка `while` целиком и программа завершается (т.к. дальнейшего кода нет).  
Подробнее о `break` см ниже.

### Цикл `while` с постусловием

Также может называться `do-while` или `do while`.   
Почти полностью совпадает с циклом `while` за исключением проверки условия. В цикле `do-while` условие проверяется 
**после** того как выполнена итерация цикла. Следующая итерация, аналогично, наступает, если условие цикла истинно.

Цикл `do-while` имеет синтаксис:

    do {
        // тело цикла.
    } while (условие);
    // код после цикла

Выполнение цикла: 
- Перед входом в цикл `условие` не проверяется, `тело цикла` выполняется в любом случае.
- После выполнения `тела цикла` (текущей итерации) проверяется `условие`.
- Если `условие` истинно, то снова выполняется `тело цикла`.
- Если `условие` ложно, то выполняется выход из цикла.
- Так продолжается пока `условие` истинно.
 
Таким образом, тело цикла `do-while` в любом случае будет выполнено хотя бы один раз, т.к. в первый раз тело 
выполняется безусловно, а условие влияет только на запуск последующей итерации цикла. 

Пример:  
Программа загадывает целое число в диапазоне от \[1;9\]. Пользователь должен угадать число. 
Пользователь вводит число в консоль. В зависимости от введённого числа, программа выводит в консоль следующее:
- "Загаданное число больше"
- "Загаданное число меньше"
- "Вы угадали!" (программа завершает работу)
- "Выход из программы" (программа завершает работу) - если введён ноль.


<!-- -->
    // LoopsDemo.java
    // doWhileDemo()
    /*
     * <code> 
     */
    Scanner scanner = new Scanner(System.in);
    int puzzle = (int) (Math.random() * 9) + 1;
    int guess;
    System.out.println("Загадано число от 1 до 9. Попробуйте угадать.");
    do {
        System.out.print("Ваш вариант? ");
        guess = scanner.nextInt();
        if (guess == 0) {
            System.out.println("Выход из программы.");
            break;
        } else if (guess == puzzle) {
            System.out.println("Вы угадали!");
            break;
        } else if (guess < puzzle) {
            System.out.println("Загаданное число больше.");
        } else {
            System.out.println("Загаданное число меньше.");
        }
    } while (true);
    /*
     * Загадано число от 1 до 9. Попробуйте угадать.
     * Ваш вариант? 5
     * Загаданное число больше.
     * Ваш вариант? 7
     * Загаданное число больше.
     * Ваш вариант? 9
     * Загаданное число меньше.
     * Ваш вариант? 8
     * Вы угадали!
     * */
<!-- -->
    
Здесь так же используется бесконечный цикл с прерыванием (уже в двух случаях).

### Цикл `for`

Циклы `while` удобно использовать, когда количество итераций цикла заранее неизвестно.  
В противоположность, цикл `for` обычно используют, когда количество необходимых итераций заранее определено. Например, 
при работе с массивами (см. [[Массивы]](../lesson03/README.md)) и коллекциями.

Синтаксис цикла `for`:

    for ([инициализация]; [условие]; [шаг]) {
        // тело цикла
    }

Каждый из трёх блоков `[инициализация]`, `[условие]`, `[шаг]` является необязательным: может быть пустым. То есть 
конструкция `for ( ; ; ) { /* тело цикла */ }` корректна.   
По факту, это будет бесконечный цикл, в котором раз за разом будет выполняться тело цикла (например, пока не 
произойдёт прерывание).

Блок `[инициализация]` выполняется только один раз, при входе в цикл. Обычно в нём производят инициализацию (т.е. 
присваивают начальные значения) переменных, используемых в цикле (переменных цикла). Также наиболее часто эти 
переменные цикла в нём же и объявляют (перед инициализацией).   
Для инициализации (и объявлеления) нескольких переменных цикла, необходимо их указать в блоке `[инициализация]` через 
запятую.  
Чаще всего в качестве переменных цикла выступают счётчики, отмеряющие количество выполненных итераций цикла (шагов). 


Блок `[условие]` проверяется и при начальном входе в цикл и при каждой следующей итерации. Если `[условие]` истинно, то 
`тело цикла` выполняется (происходит итерация цикла). Если `[условие]` ложно, то происходит выход из цикла.  
Блок `[условие]` может содержать *несколько* выражений (например, проверки нескольких переменных). Для этого нужно их 
указать в блоке `[условие]` через запятую.  
Каждое из выражений должно принимать значение типа `boolean`. Условие цикла считается выполненым, только если все 
выражения в `[условии]` истинны. Если хотя бы одно условие ложно, происходит выход из цикла.  
Пустой блок `[условие]` трактуется как `true`. Т.е. цикл без условия - бесконечный цикл (например, до прерывания).
Обычно в блоке `[условие]` проверяется, достигнуто ли желаемое количество выполненных итераций цикла: для этого 
сравниваются переменные цикла (счётчики) с каким-то значением.

Блок `[шаг]` содержит инструкции, которые выполняются **каждый раз** после завершения тела цикла, но **до проверки** 
`[условия]` в следующей итерации.  
Блок `[шаг]` может содержать несколько инструкций, для этого их нужно указать через запятую.
Обычно, в шаге цикла обновляются переменные цикла (счётчики).  

Пример использования цикла `for`:  
Вывести в консоль все чётные натуральные двузначные числа.

    // LoopsDemo.java
    // forDemo()
    /*
     * <code> 
     */
    for (int i = 10; i < 100; i++) {
        if (i % 2 == 0) System.out.print(i + " ");
    }
    System.out.println();
    // 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 
    // 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 

Циклы `while` и `for` взаимозаменяемы. Разница в удобстве применения: в `for` инициализация переменных и шаг итерации 
(если они нужны) - встроены, а для `while` их нужно выполнять вручную.
 
Например, конструкции `while (condition) {/* тело цикла */}` и `for ( ; condition ; ) {/* тело цикла */}` полностью 
равнозначны.  
Предыдущий пример тоже можно было решить через `while`:

    int i = 10;
    while (i < 100) {
        if (i % 2 == 0) System.out.print(i + " ");
        i++;
    }
    System.out.println();
    // 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 
    // 56 58 60 62 64 66 68 70 72 74 76 78 80 82 84 86 88 90 92 94 96 98 

### Улучшенный (enhanced) цикл `for`

Начиная с версии Java 5 для цикла `for` появилась новая, улучшенная форма записи, известная так же как `enhanced for`, 
`foreach`, или `for each`.  
Он используется, когда необходимо в цикле перебрать *все* элементы из какого-то перечислимого набора.  
Перечислимым набором является объект, реализующий интерфейс `java.lang.Iterable` (про реализацию интерфейсов см. 
[[Интерфейсы]](../lesson07/README.md)). На практике, `foreach` может быть использован с массивами (см. 
[[Массивы]](../lesson03/README.md)) и большей частью колллекций<!-- (см. [[Коллекции]]())-->.

Синтаксис цикла `foreach`:

    for (ТипДанных элемент : набор) {
        // тело цикла
    }

где:
- `набор` - имя переменной, в которой хранится перебираемый набор;  
- `ТипДанных` - какой тип данных хранится в перебираемом наборе; 
- `элемент` - имя локальной переменной цикла. При этом:
    - запись `ТипДанных элемент` объявляет эту переменную цикла, т.е. `элемент` имеет тип `ТипДанных`;
    - переменная `элемент` существует только внутри цикла 
    - на каждой итерации цикла в переменную `элемент` **копируется** значение очередного элемента, взятого из `набора`. 

Цикл `foreach` последовательно перебирает **все** элементы набора, каждый раз выполняя тело цикла. 

Явной проверки условия в цикле `foreach` нет. По факту же, условие цикла `foreach` проверяет есть ли в `наборе` ещё 
один, следующий элемент, который ещё не был обработан.  

В отличие от других циклов, где осуществляется прямой доступ к данным, цикл `foreach` работает с **копиями** данных: 
значение переменной `элемент` на каждой итерации цикла является **копией** очередного элемента из `набора`; при 
действиях с `элементом` оригинальные элементы `набора` не затрагиваются (остаются неизменны).   

Пример использования цикла `foreach`:
Дан массив целых чисел. Вывести в консоль квадраты каждого из элементов массива. Сам массив не изменять.

    // LoopsDemo.java
    // foreachDemo()
    /*
     * <code> 
     */
    int[] numbers = new int[(int) (Math.random() * 5) + 5]; // масссив целых чисел длиной от 5 до 9
    for (int i = 0; i < numbers.length; i++) {
        numbers[i] = (int) (Math.random() * 100); // заполняем массив произвольными числами от 0 до 99
    }
    System.out.println("Исходный массив: " + Arrays.toString(numbers)); // выводим содержимое массива
    System.out.print("Квадраты элементов массива: [");
    for (int n : numbers) {
        System.out.print(n * n + " ");
    }
    System.out.println("]");
    // проверяем, что массив не изменился
    System.out.println("Массив после выполнения цикла 'foreach': " + Arrays.toString(numbers)); 
    /*
     * Исходный массив: [98, 38, 8, 21, 53, 61, 32]
     * Квадраты элементов массива: [9604 1444 64 441 2809 3721 1024 ]
     * Массив после выполнения цикла 'foreach':: [98, 38, 8, 21, 53, 61, 32]
     * */

### Вложенные циклы

Тело цикла может содержать любые инструкции. В том числе оно может содержать и другой цикл. Такая конструкция 
называется **вложенным циклом**, а сами циклы по отношению к друг другу называются **внешним** и **внутренним**.

На каждой итерации *внешнего* цикла будет запускаться *внутренний* цикл целиком: пока все итерации *внутреннего* цикла 
не выполнятся, текущая итерация *внешного* цикла не продолжится.

Вложенность циклов не ограничена.

Пример:  
Вывести в консоль, по возврастанию, все двузначные целые числа, у которых вторая цифра меньше первой.

    // LoopsDemo.java
    // nestedLoopsDemo()
    /*
     * <code> 
     */
    for (int i = 1; i < 10; i++) {
        for (int j = 0; j < i; j++) {
            System.out.print(" " + i + j);
        }
    }
    System.out.println();
    // 10 20 21 30 31 32 40 41 42 43 50 51 52 53 54 60 61 62 63 64 65 70 71 72 73 74 75 76 80 81 82 83 84 85 86 87 90 
    // 91 92 93 94 95 96 97 98

### Директивы `break` и `continue`

Иногда для алгоритма программы бывает необходимо прервать выполнение текущей итерации цикла (и перейти к следуюющей; с 
проверкой условия цикла) или прервать выполнение цикла целиком.

Для этих целей в языке Java есть два ключевых слова (инструкции, директивы): `continue` и `break`. Их можно 
использовать только внутри циклов. (Директива `break` ещё используется в ветвлении `switch` 
(см. [[Условные конструкции]](ConditionalStatements.md))).

Директива `continue` **прерывает выполнение текущей итерации** цикла, в котором находится эта директива, и исполнение 
кода переходит к *следующей* итерации этого цикла (начиная с проверки условия цикла).

Директива `break` **прерывает выполнение текущего цикла**, в котором находится эта директива; происходит выход из 
цикла. Если, например, текущий цикл - внутренний, то `break` прерывает именно внутренний цикл, и исполнение кода 
переходит к продолжению итерации внешнего цикла.  

Директивы `break` и `continue` имеет смысл использовать при выполнении какого-то условия (успешная проверка с `if`). 

#### Метки

**Метки** - это имена, которые можно присвоить циклам (и только циклам). 
Требования к именам меток такие же как и к именам переменных.

Метки используются для того, чтобы в директивах `break` или `continue` указать с каким именно циклом необходимо 
произвести действие.

Для пометки цикла меткой необходимо перед объявлением цикла указать имя метки с символом `:`

Пример: 

    outer: 
    for (int i = 0; i < 10; i++) {
        // внешний цикл
        middle: 
        for (int j = 0; j < 10; j++) {
            // промежуточный цикл
            inner:
            for (int k = 0; k < 10; k++) {
                // внутренний цикл
                if (`условие`) {
                    /* место для директивы */ 
                }
                /* дальнейший код внутреннего цикла */
            }
            /* дальнейший код промежуточного цикла */
        }
        /* дальнейший код внешнего цикла */
    }
    /* дальнейший код после внешнего цикла */
    

Что будет происходить, если в `место для директивы` поставить `break` или `continue` с меткой:
- `break;` - при выполнении `условия` внутренний цикл прерывается; происходит выход из внутреннего цикла; продолжается 
    текущая итерация промежуточного цикла; когда она закончится, будет следующая итерация промежуточного цикла: 
    `j++` и запуск нового внутреннего цикла.  
- `break inner;` - полностью то же самое, что и предыдущий вариант.
- `break middle;` - при выполнении `условия` прерывается и внутренний, и промежуточный цикл; происходит выход из 
    промежуточного цикла; продолжается текущая итерация внешнего цикла; когда она закончится, будет следующая итерация 
    внешнего цикла: `i++`, запуск нового промежуточного цикла, а в нём запуск нового внутреннего цикла.
- `break outer;` - при выполнении `условия` прерываются все три цикла; исполнение программы переходит к коду после 
    внешнего цикла/
- `continue;` - при выполнении `условия` прерывается текущая итерация внутреннего цикла; дальнейший код внутреннего 
    цикла не выполняется, а начинается новая итерация внутреннего цикла: `k++` и проверка условия `k < 10`.
- `continue inner;` - полностью то же самое, что и предыдущий вариант.
- `continue middle;` - при выполнении `условия` прерываются внутренний цикл и текущая итерация промежуточного цикла; 
    дальнейший код промежуточного цикла не выполняется; начинается новая итерация промежуточного цикла: `j++`, проверка 
    условия `j < 10` и если оно верно - запуск нового внутреннего цикла.
- `continue outer;` - при выполнении `условия` прерываются внутренний и промежуточный циклы и текущая итерация внешнего 
    цикла; дальнейший код внешнего цикла не выполняется; начинается новая итерация внешнего цикла: `i++`, проверка 
    условия `i < 10` и если оно верно - запуск нового промежуточного цикла, а в нём - запуск нового внутреннего цикла.
    
Как можно заметить, помечать самый внутренний цикл не имеет смысла.           
